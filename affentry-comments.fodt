<?xml version="1.0" encoding="UTF-8"?>

<office:document xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0" xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:number="urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0" xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0" xmlns:chart="urn:oasis:names:tc:opendocument:xmlns:chart:1.0" xmlns:dr3d="urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:form="urn:oasis:names:tc:opendocument:xmlns:form:1.0" xmlns:script="urn:oasis:names:tc:opendocument:xmlns:script:1.0" xmlns:config="urn:oasis:names:tc:opendocument:xmlns:config:1.0" xmlns:ooo="http://openoffice.org/2004/office" xmlns:ooow="http://openoffice.org/2004/writer" xmlns:oooc="http://openoffice.org/2004/calc" xmlns:dom="http://www.w3.org/2001/xml-events" xmlns:xforms="http://www.w3.org/2002/xforms" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rpt="http://openoffice.org/2005/report" xmlns:of="urn:oasis:names:tc:opendocument:xmlns:of:1.2" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:grddl="http://www.w3.org/2003/g/data-view#" xmlns:officeooo="http://openoffice.org/2009/office" xmlns:tableooo="http://openoffice.org/2009/table" xmlns:drawooo="http://openoffice.org/2010/draw" xmlns:calcext="urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0" xmlns:loext="urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0" xmlns:field="urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0" xmlns:formx="urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0" xmlns:css3t="http://www.w3.org/TR/css3-text/" office:version="1.2" office:mimetype="application/vnd.oasis.opendocument.text">
 <office:meta><dc:date>2018-03-02T16:12:04.990210374</dc:date><meta:editing-duration>PT1H57M52S</meta:editing-duration><meta:editing-cycles>21</meta:editing-cycles><meta:generator>LibreOffice/5.4.5.1$Linux_X86_64 LibreOffice_project/40m0$Build-1</meta:generator><meta:document-statistic meta:table-count="0" meta:image-count="0" meta:object-count="0" meta:page-count="16" meta:paragraph-count="983" meta:word-count="5658" meta:character-count="35864" meta:non-whitespace-character-count="25547"/></office:meta>
 <office:settings>
  <config:config-item-set config:name="ooo:view-settings">
   <config:config-item config:name="ViewAreaTop" config:type="long">147743</config:config-item>
   <config:config-item config:name="ViewAreaLeft" config:type="long">2752</config:config-item>
   <config:config-item config:name="ViewAreaWidth" config:type="long">23656</config:config-item>
   <config:config-item config:name="ViewAreaHeight" config:type="long">22677</config:config-item>
   <config:config-item config:name="ShowRedlineChanges" config:type="boolean">true</config:config-item>
   <config:config-item config:name="InBrowseMode" config:type="boolean">false</config:config-item>
   <config:config-item-map-indexed config:name="Views">
    <config:config-item-map-entry>
     <config:config-item config:name="ViewId" config:type="string">view2</config:config-item>
     <config:config-item config:name="ViewLeft" config:type="long">4198</config:config-item>
     <config:config-item config:name="ViewTop" config:type="long">163082</config:config-item>
     <config:config-item config:name="VisibleLeft" config:type="long">2752</config:config-item>
     <config:config-item config:name="VisibleTop" config:type="long">147743</config:config-item>
     <config:config-item config:name="VisibleRight" config:type="long">26405</config:config-item>
     <config:config-item config:name="VisibleBottom" config:type="long">170418</config:config-item>
     <config:config-item config:name="ZoomType" config:type="short">0</config:config-item>
     <config:config-item config:name="ViewLayoutColumns" config:type="short">1</config:config-item>
     <config:config-item config:name="ViewLayoutBookMode" config:type="boolean">false</config:config-item>
     <config:config-item config:name="ZoomFactor" config:type="short">100</config:config-item>
     <config:config-item config:name="IsSelectedFrame" config:type="boolean">false</config:config-item>
     <config:config-item config:name="AnchoredTextOverflowLegacy" config:type="boolean">false</config:config-item>
    </config:config-item-map-entry>
   </config:config-item-map-indexed>
  </config:config-item-set>
  <config:config-item-set config:name="ooo:configuration-settings">
   <config:config-item config:name="PrintPaperFromSetup" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintFaxName" config:type="string"/>
   <config:config-item config:name="PrintSingleJobs" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintProspectRTL" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintProspect" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintReversed" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintTextPlaceholder" config:type="boolean">false</config:config-item>
   <config:config-item config:name="DoNotJustifyLinesWithManualBreak" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AlignTabStopPosition" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintLeftPages" config:type="boolean">true</config:config-item>
   <config:config-item config:name="IgnoreFirstLineIndentInNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrinterSetup" config:type="base64Binary"/>
   <config:config-item config:name="CollapseEmptyCellPara" config:type="boolean">true</config:config-item>
   <config:config-item config:name="RedlineProtectionKey" config:type="base64Binary"/>
   <config:config-item config:name="UseOldPrinterMetrics" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UseOldNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AddExternalLeading" config:type="boolean">true</config:config-item>
   <config:config-item config:name="TreatSingleColumnBreakAsPageBreak" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UpdateFromTemplate" config:type="boolean">true</config:config-item>
   <config:config-item config:name="IsLabelDocument" config:type="boolean">false</config:config-item>
   <config:config-item config:name="RsidRoot" config:type="int">1317001</config:config-item>
   <config:config-item config:name="ConsiderTextWrapOnObjPos" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TableRowKeep" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TabsRelativeToIndent" config:type="boolean">true</config:config-item>
   <config:config-item config:name="SaveVersionOnClose" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UseFormerTextWrapping" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ChartAutoUpdate" config:type="boolean">true</config:config-item>
   <config:config-item config:name="AddParaTableSpacingAtStart" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintTables" config:type="boolean">true</config:config-item>
   <config:config-item config:name="AllowPrintJobCancel" config:type="boolean">true</config:config-item>
   <config:config-item config:name="AddParaTableSpacing" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintDrawings" config:type="boolean">true</config:config-item>
   <config:config-item config:name="AddParaSpacingToTableCells" config:type="boolean">true</config:config-item>
   <config:config-item config:name="UseFormerLineSpacing" config:type="boolean">false</config:config-item>
   <config:config-item config:name="OutlineLevelYieldsNumbering" config:type="boolean">false</config:config-item>
   <config:config-item-map-indexed config:name="ForbiddenCharacters">
    <config:config-item-map-entry>
     <config:config-item config:name="Language" config:type="string">zxx</config:config-item>
     <config:config-item config:name="Country" config:type="string"/>
     <config:config-item config:name="Variant" config:type="string"/>
     <config:config-item config:name="BeginLine" config:type="string"/>
     <config:config-item config:name="EndLine" config:type="string"/>
    </config:config-item-map-entry>
   </config:config-item-map-indexed>
   <config:config-item config:name="LinkUpdateMode" config:type="short">1</config:config-item>
   <config:config-item config:name="DoNotResetParaAttrsForNumFont" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ApplyUserData" config:type="boolean">true</config:config-item>
   <config:config-item config:name="StylesNoDefault" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbeddedDatabaseName" config:type="string"/>
   <config:config-item config:name="FloattableNomargins" config:type="boolean">false</config:config-item>
   <config:config-item config:name="BackgroundParaOverDrawings" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintBlackFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrinterName" config:type="string"/>
   <config:config-item config:name="UseFormerObjectPositioning" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TabOverMargin" config:type="boolean">false</config:config-item>
   <config:config-item config:name="SaveGlobalDocumentLinks" config:type="boolean">false</config:config-item>
   <config:config-item config:name="CurrentDatabaseDataSource" config:type="string"/>
   <config:config-item config:name="IsKernAsianPunctuation" config:type="boolean">false</config:config-item>
   <config:config-item config:name="CharacterCompressionType" config:type="short">0</config:config-item>
   <config:config-item config:name="SmallCapsPercentage66" config:type="boolean">false</config:config-item>
   <config:config-item config:name="CurrentDatabaseCommand" config:type="string"/>
   <config:config-item config:name="CurrentDatabaseCommandType" config:type="int">0</config:config-item>
   <config:config-item config:name="FieldAutoUpdate" config:type="boolean">true</config:config-item>
   <config:config-item config:name="IgnoreTabsAndBlanksForLineCalculation" config:type="boolean">false</config:config-item>
   <config:config-item config:name="LoadReadonly" config:type="boolean">false</config:config-item>
   <config:config-item config:name="DoNotCaptureDrawObjsOnPage" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ClipAsCharacterAnchoredWriterFlyFrames" config:type="boolean">false</config:config-item>
   <config:config-item config:name="SurroundTextWrapSmall" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UnxForceZeroExtLeading" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TabAtLeftIndentForParagraphsInList" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintRightPages" config:type="boolean">true</config:config-item>
   <config:config-item config:name="Rsid" config:type="int">3991602</config:config-item>
   <config:config-item config:name="MathBaselineAlignment" config:type="boolean">true</config:config-item>
   <config:config-item config:name="MsWordCompTrailingBlanks" config:type="boolean">false</config:config-item>
   <config:config-item config:name="InvertBorderSpacing" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbedFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrinterIndependentLayout" config:type="string">high-resolution</config:config-item>
   <config:config-item config:name="TabOverflow" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintGraphics" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PropLineSpacingShrinksFirstLine" config:type="boolean">true</config:config-item>
   <config:config-item config:name="UnbreakableNumberings" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AddFrameOffsets" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ClippedPictures" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbedSystemFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ApplyParagraphMarkFormatToNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="SubtractFlysAnchoredAtFlys" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AddVerticalFrameOffsets" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ProtectForm" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintEmptyPages" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintControls" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintHiddenText" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintAnnotationMode" config:type="short">0</config:config-item>
   <config:config-item config:name="PrintPageBackground" config:type="boolean">true</config:config-item>
  </config:config-item-set>
 </office:settings>
 <office:scripts>
  <office:script script:language="ooo:Basic">
   <ooo:libraries xmlns:ooo="http://openoffice.org/2004/office" xmlns:xlink="http://www.w3.org/1999/xlink">
    <ooo:library-embedded ooo:name="Standard"/>
   </ooo:libraries>
  </office:script>
 </office:scripts>
 <office:font-face-decls>
  <style:font-face style:name="Lohit Devanagari1" svg:font-family="&apos;Lohit Devanagari&apos;"/>
  <style:font-face style:name="Courier New" svg:font-family="&apos;Courier New&apos;" style:font-family-generic="modern" style:font-pitch="fixed"/>
  <style:font-face style:name="DejaVu Sans Mono" svg:font-family="&apos;DejaVu Sans Mono&apos;" style:font-family-generic="modern" style:font-pitch="fixed"/>
  <style:font-face style:name="Liberation Mono" svg:font-family="&apos;Liberation Mono&apos;" style:font-family-generic="modern" style:font-pitch="fixed"/>
  <style:font-face style:name="Liberation Serif" svg:font-family="&apos;Liberation Serif&apos;" style:font-family-generic="roman" style:font-pitch="variable"/>
  <style:font-face style:name="Liberation Sans" svg:font-family="&apos;Liberation Sans&apos;" style:font-family-generic="swiss" style:font-pitch="variable"/>
  <style:font-face style:name="Lohit Devanagari" svg:font-family="&apos;Lohit Devanagari&apos;" style:font-family-generic="system" style:font-pitch="variable"/>
  <style:font-face style:name="Noto Sans CJK SC Regular" svg:font-family="&apos;Noto Sans CJK SC Regular&apos;" style:font-family-generic="system" style:font-pitch="variable"/>
 </office:font-face-decls>
 <office:styles>
  <style:default-style style:family="graphic">
   <style:graphic-properties svg:stroke-color="#3465a4" draw:fill-color="#729fcf" fo:wrap-option="no-wrap" draw:shadow-offset-x="0.1181in" draw:shadow-offset-y="0.1181in" draw:start-line-spacing-horizontal="0.1114in" draw:start-line-spacing-vertical="0.1114in" draw:end-line-spacing-horizontal="0.1114in" draw:end-line-spacing-vertical="0.1114in" style:flow-with-text="false"/>
   <style:paragraph-properties style:text-autospace="ideograph-alpha" style:line-break="strict" style:font-independent-line-spacing="false">
    <style:tab-stops/>
   </style:paragraph-properties>
   <style:text-properties style:use-window-font-color="true" style:font-name="Liberation Serif" fo:font-size="12pt" fo:language="zxx" fo:country="none" style:letter-kerning="true" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none"/>
  </style:default-style>
  <style:default-style style:family="paragraph">
   <style:paragraph-properties fo:hyphenation-ladder-count="no-limit" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:tab-stop-distance="0.4925in" style:writing-mode="page"/>
   <style:text-properties style:use-window-font-color="true" style:font-name="Liberation Serif" fo:font-size="12pt" fo:language="zxx" fo:country="none" style:letter-kerning="true" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none" fo:hyphenate="false" fo:hyphenation-remain-char-count="2" fo:hyphenation-push-char-count="2"/>
  </style:default-style>
  <style:default-style style:family="table">
   <style:table-properties table:border-model="collapsing"/>
  </style:default-style>
  <style:default-style style:family="table-row">
   <style:table-row-properties fo:keep-together="auto"/>
  </style:default-style>
  <style:style style:name="Standard" style:family="paragraph" style:class="text"/>
  <style:style style:name="Heading" style:family="paragraph" style:parent-style-name="Standard" style:next-style-name="Text_20_body" style:class="text">
   <style:paragraph-properties fo:margin-top="0.1665in" fo:margin-bottom="0.0835in" loext:contextual-spacing="false" fo:keep-with-next="always"/>
   <style:text-properties style:font-name="Liberation Sans" fo:font-family="&apos;Liberation Sans&apos;" style:font-family-generic="swiss" style:font-pitch="variable" fo:font-size="14pt" style:font-name-asian="Noto Sans CJK SC Regular" style:font-family-asian="&apos;Noto Sans CJK SC Regular&apos;" style:font-family-generic-asian="system" style:font-pitch-asian="variable" style:font-size-asian="14pt" style:font-name-complex="Lohit Devanagari" style:font-family-complex="&apos;Lohit Devanagari&apos;" style:font-family-generic-complex="system" style:font-pitch-complex="variable" style:font-size-complex="14pt"/>
  </style:style>
  <style:style style:name="Text_20_body" style:display-name="Text body" style:family="paragraph" style:parent-style-name="Standard" style:class="text">
   <style:paragraph-properties fo:margin-top="0in" fo:margin-bottom="0.0972in" loext:contextual-spacing="false" fo:line-height="120%"/>
  </style:style>
  <style:style style:name="List" style:family="paragraph" style:parent-style-name="Text_20_body" style:class="list">
   <style:text-properties style:font-size-asian="12pt" style:font-name-complex="Lohit Devanagari1" style:font-family-complex="&apos;Lohit Devanagari&apos;"/>
  </style:style>
  <style:style style:name="Caption" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
   <style:paragraph-properties fo:margin-top="0.0835in" fo:margin-bottom="0.0835in" loext:contextual-spacing="false" text:number-lines="false" text:line-number="0"/>
   <style:text-properties fo:font-size="12pt" fo:font-style="italic" style:font-size-asian="12pt" style:font-style-asian="italic" style:font-name-complex="Lohit Devanagari1" style:font-family-complex="&apos;Lohit Devanagari&apos;" style:font-size-complex="12pt" style:font-style-complex="italic"/>
  </style:style>
  <style:style style:name="Index" style:family="paragraph" style:parent-style-name="Standard" style:class="index">
   <style:paragraph-properties text:number-lines="false" text:line-number="0"/>
   <style:text-properties style:font-size-asian="12pt" style:font-name-complex="Lohit Devanagari1" style:font-family-complex="&apos;Lohit Devanagari&apos;"/>
  </style:style>
  <style:style style:name="Preformatted_20_Text" style:display-name="Preformatted Text" style:family="paragraph" style:parent-style-name="Standard" style:class="html">
   <style:paragraph-properties fo:margin-top="0in" fo:margin-bottom="0in" loext:contextual-spacing="false"/>
   <style:text-properties style:font-name="Liberation Mono" fo:font-family="&apos;Liberation Mono&apos;" style:font-family-generic="modern" style:font-pitch="fixed" fo:font-size="10pt" style:font-name-asian="DejaVu Sans Mono" style:font-family-asian="&apos;DejaVu Sans Mono&apos;" style:font-family-generic-asian="modern" style:font-pitch-asian="fixed" style:font-size-asian="10pt" style:font-name-complex="Liberation Mono" style:font-family-complex="&apos;Liberation Mono&apos;" style:font-family-generic-complex="modern" style:font-pitch-complex="fixed" style:font-size-complex="10pt"/>
  </style:style>
  <style:style style:name="Numbering_20_Symbols" style:display-name="Numbering Symbols" style:family="text"/>
  <text:outline-style style:name="Outline">
   <text:outline-level-style text:level="1" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="2" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="3" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="4" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="5" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="6" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="7" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="8" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="9" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="10" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
  </text:outline-style>
  <text:list-style style:name="Numbering_20_2" style:display-name="Numbering 2">
   <text:list-level-style-number text:level="1" text:style-name="Numbering_20_Symbols" style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment" fo:text-align="end">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.1965in" fo:text-indent="-0.1965in" fo:margin-left="0.1965in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="2" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="2">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.3929in" fo:text-indent="-0.1965in" fo:margin-left="0.3929in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="3" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="3">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.7866in" fo:text-indent="-0.3937in" fo:margin-left="0.7866in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="4" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="4">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1.2791in" fo:text-indent="-0.4925in" fo:margin-left="1.2791in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="5" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="5">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1.8693in" fo:text-indent="-0.5902in" fo:margin-left="1.8693in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="6" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="6">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="2.5783in" fo:text-indent="-0.7091in" fo:margin-left="2.5783in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="7" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="7">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="3.4839in" fo:text-indent="-0.9055in" fo:margin-left="3.4839in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="8" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="8">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="4.5075in" fo:text-indent="-1.0236in" fo:margin-left="4.5075in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="9" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="9">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="5.6102in" fo:text-indent="-1.1028in" fo:margin-left="5.6102in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="10" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="10">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="6.8311in" fo:text-indent="-1.2209in" fo:margin-left="6.8311in"/>
    </style:list-level-properties>
   </text:list-level-style-number>
  </text:list-style>
  <text:notes-configuration text:note-class="footnote" style:num-format="1" text:start-value="0" text:footnotes-position="page" text:start-numbering-at="document"/>
  <text:notes-configuration text:note-class="endnote" style:num-format="i" text:start-value="0"/>
  <text:linenumbering-configuration text:number-lines="false" text:offset="0.1965in" style:num-format="1" text:number-position="left" text:increment="5"/>
 </office:styles>
 <office:automatic-styles>
  <style:style style:name="P1" style:family="paragraph" style:parent-style-name="Preformatted_20_Text">
   <style:text-properties fo:background-color="#fff200"/>
  </style:style>
  <style:style style:name="P2" style:family="paragraph" style:parent-style-name="Preformatted_20_Text">
   <style:text-properties fo:background-color="transparent"/>
  </style:style>
  <style:style style:name="P3" style:family="paragraph" style:parent-style-name="Standard">
   <style:paragraph-properties fo:margin-left="0in" fo:margin-right="0in" fo:margin-top="0in" fo:margin-bottom="0in" loext:contextual-spacing="false" fo:line-height="100%" fo:text-align="start" style:justify-single-word="false" fo:hyphenation-ladder-count="no-limit" fo:text-indent="0in" style:auto-text-indent="false" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:writing-mode="lr-tb">
    <style:tab-stops/>
   </style:paragraph-properties>
   <style:text-properties fo:hyphenate="false" fo:hyphenation-remain-char-count="2" fo:hyphenation-push-char-count="2"/>
  </style:style>
  <style:style style:name="P4" style:family="paragraph" style:parent-style-name="Preformatted_20_Text" style:list-style-name="Numbering_20_2"/>
  <style:style style:name="P5" style:family="paragraph" style:parent-style-name="Preformatted_20_Text" style:list-style-name="Numbering_20_2">
   <style:text-properties fo:background-color="#fff200"/>
  </style:style>
  <style:style style:name="P6" style:family="paragraph" style:parent-style-name="Preformatted_20_Text" style:list-style-name="Numbering_20_2">
   <style:text-properties fo:background-color="transparent"/>
  </style:style>
  <style:style style:name="P7" style:family="paragraph">
   <style:paragraph-properties fo:margin-left="0in" fo:margin-right="0in" fo:margin-top="0in" fo:margin-bottom="0in" fo:line-height="100%" fo:text-align="start" fo:text-indent="0in" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:writing-mode="lr-tb">
    <style:tab-stops/>
   </style:paragraph-properties>
   <style:text-properties fo:hyphenate="false"/>
  </style:style>
  <style:style style:name="T1" style:family="text">
   <style:text-properties fo:background-color="#faa61a" loext:char-shading-value="0"/>
  </style:style>
  <style:style style:name="T2" style:family="text">
   <style:text-properties fo:background-color="#fff200" loext:char-shading-value="0"/>
  </style:style>
  <style:style style:name="T3" style:family="text">
   <style:text-properties fo:background-color="#ef413d" loext:char-shading-value="0"/>
  </style:style>
  <style:style style:name="T4" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" style:use-window-font-color="true" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="normal" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" loext:char-shading-value="0" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T5" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" style:use-window-font-color="true" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="bold" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" loext:char-shading-value="0" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T6" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" fo:color="#000000" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="normal" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" loext:char-shading-value="0" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T7" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" fo:color="#000000" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="bold" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" loext:char-shading-value="0" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T8" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" fo:color="#000000" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Courier New" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="normal" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" loext:char-shading-value="0" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T9" style:family="text">
   <style:text-properties fo:background-color="#ffffff" loext:char-shading-value="0"/>
  </style:style>
  <style:style style:name="T10" style:family="text">
   <style:text-properties fo:background-color="transparent" loext:char-shading-value="0"/>
  </style:style>
  <style:style style:name="T11" style:family="text">
   <style:text-properties fo:background-color="#0066b3" loext:char-shading-value="0"/>
  </style:style>
  <style:style style:name="T12" style:family="text">
   <style:text-properties fo:background-color="#00aaad" loext:char-shading-value="0"/>
  </style:style>
  <style:style style:name="T13" style:family="text">
   <style:text-properties fo:background-color="#adc5e7" loext:char-shading-value="0"/>
  </style:style>
  <style:style style:name="T14" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" style:use-window-font-color="true" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="normal" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T15" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" fo:color="#000000" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="normal" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:page-layout style:name="pm1">
   <style:page-layout-properties fo:page-width="8.2681in" fo:page-height="11.6929in" style:num-format="1" style:print-orientation="portrait" fo:margin-top="0.5118in" fo:margin-bottom="0.5118in" fo:margin-left="0.5902in" fo:margin-right="0.5902in" style:writing-mode="lr-tb" style:footnote-max-height="0in">
    <style:footnote-sep style:width="0.0071in" style:distance-before-sep="0.0398in" style:distance-after-sep="0.0398in" style:line-style="solid" style:adjustment="left" style:rel-width="25%" style:color="#000000"/>
   </style:page-layout-properties>
   <style:header-style/>
   <style:footer-style/>
  </style:page-layout>
 </office:automatic-styles>
 <office:master-styles>
  <style:master-page style:name="Standard" style:page-layout-name="pm1"/>
 </office:master-styles>
 <office:body>
  <office:text text:use-soft-page-breaks="true">
   <office:forms form:automatic-focus="false" form:apply-design-mode="false"/>
   <text:sequence-decls>
    <text:sequence-decl text:display-outline-level="0" text:name="Illustration"/>
    <text:sequence-decl text:display-outline-level="0" text:name="Table"/>
    <text:sequence-decl text:display-outline-level="0" text:name="Text"/>
    <text:sequence-decl text:display-outline-level="0" text:name="Drawing"/>
   </text:sequence-decls>
   <text:list xml:id="list317625817" text:style-name="Numbering_20_2">
    <text:list-item>
     <text:p text:style-name="P4">/* ***** BEGIN LICENSE BLOCK *****</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Version: MPL 1.1/GPL 2.0/LGPL 2.1</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Copyright (C) 2002-2017 Németh László</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* The contents of this file are subject to the Mozilla Public License Version</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* the License. You may obtain a copy of the License at</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* http://www.mozilla.org/MPL/</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* for the specific language governing rights and limitations under the</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* License.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Alternatively, the contents of this file may be used under the terms of</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* in which case the provisions of the GPL or the LGPL are applicable instead</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* of those above. If you wish to allow use of your version of this file only</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* under the terms of either the GPL or the LGPL, and not to allow others to</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* use your version of this file under the terms of the MPL, indicate your</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* decision by deleting the provisions above and replace them with the notice</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* and other provisions required by the GPL or the LGPL. If you do not delete</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* the provisions above, a recipient may use your version of this file under</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* the terms of any one of the MPL, the GPL or the LGPL.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* ***** END LICENSE BLOCK ***** */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">/*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* And Contributors. <text:s/>All rights reserved.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Redistribution and use in source and binary forms, with or without</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* modification, are permitted provided that the following conditions</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* are met:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* 1. Redistributions of source code must retain the above copyright</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>notice, this list of conditions and the following disclaimer.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* 2. Redistributions in binary form must reproduce the above copyright</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>notice, this list of conditions and the following disclaimer in the</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>documentation and/or other materials provided with the distribution.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* 3. All modifications to the source code must be clearly marked as</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>such. <text:s/>Binary redistributions based on modified source code</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>must be clearly marked as modified versions in the documentation</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>and/or other materials provided with the distribution.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* ``AS IS&apos;&apos; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. <text:s/>IN NO EVENT SHALL</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s/>* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* SUCH DAMAGE.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*/</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &lt;stdlib.h&gt;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &lt;string.h&gt;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &lt;stdio.h&gt;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &lt;ctype.h&gt;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &quot;affentry.hxx&quot;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &quot;csutil.hxx&quot;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:span text:style-name="T1">AffEntry::~AffEntry()</text:span> {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (opts &amp; aeLONGCOND)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>free(c.l.conds2);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (morphcode &amp;&amp; !(opts &amp; aeALIASM))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>free(morphcode);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (contclass &amp;&amp; !(opts &amp; aeALIASF))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>free(contclass);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:span text:style-name="T1">PfxEntry::PfxEntry</text:span>(AffixMgr* pmgr)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// register affix manager</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>: pmyMgr(pmgr),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>next(NULL),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>nexteq(NULL),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>nextne(NULL),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>flgnxt(NULL) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">// add prefix to this word assuming conditions hold</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::string <text:span text:style-name="T1">PfxEntry::add</text:span>(const char* word, size_t len) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:span text:style-name="T10"><text:s text:c="2"/></text:span><office:annotation office:name="__Annotation__2262_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T13:04:46.967830672</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">Add prefix if all of the following applies:</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">1) After stripping at least a word length of 1 must remain. OR The word length is 0 the global fullstrip option is set.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">2) The word length is greater or equal to number of conditions.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">3) Test condtions must apply to word.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">4) No stripping is defined. OR The word starts with the stripping characters.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14"/></text:p>
      </office:annotation><text:span text:style-name="T10">if</text:span><office:annotation-end office:name="__Annotation__2262_3738427752"/><text:span text:style-name="T10"> ((len &gt; strip.size() || (len == 0 &amp;&amp; pmyMgr-&gt;get_fullstrip</text:span>())) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item text:start-value="1">
     <text:p text:style-name="P4"><text:s text:c="6"/>(len &gt;= numconds) &amp;&amp; <text:span text:style-name="T13">test_condition</text:span>(word) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>(!strip.size() || (strncmp(word, strip.c_str(), strip.size()) == 0))) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">/* we have a match so add prefix */</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>result.assign(appnd);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>result.append(word + strip.size());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return <office:annotation office:name="__Annotation__2261_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T13:04:00.695182239</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">prefix+stripped_word</text:span></text:p>
      </office:annotation>result<office:annotation-end office:name="__Annotation__2261_3738427752"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">inline char* <text:span text:style-name="T1">PfxEntry::nextchar</text:span>(char* p) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (p) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>p++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (opts &amp; aeLONGCOND) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// jump to the 2nd part of the condition</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (p == c.conds + MAXCONDLEN_1)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return c.l.conds2;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// end of the MAXCONDLEN length condition</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else if (p == c.conds + MAXCONDLEN)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return *p ? p : NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">inline <office:annotation office:name="__Annotation__12473_854338662">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T00:47:02.073413506</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">Return value is only 0 or 1</text:span></text:p>
      </office:annotation>int<office:annotation-end office:name="__Annotation__12473_854338662"/> <office:annotation office:name="__Annotation__12389_854338662">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T00:19:04.293409202</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">Called by:</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">- add</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">- checkword</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">- check_twosfx</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">- check_twosfx_morph</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">- check_morph</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">Good testcase is condition.aff</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">Similar method exists for suffix entry.</text:span></text:p>
      </office:annotation><text:span text:style-name="T1">PfxEntry::test_condition</text:span><office:annotation-end office:name="__Annotation__12389_854338662"/>(const char* st) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* pos = NULL; <text:s/><text:span text:style-name="T2">// group with pos input position</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>bool neg = false; <text:s text:c="7"/><text:span text:style-name="T2">// complementer</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>bool ingroup = false; <text:s text:c="3"/><text:span text:style-name="T2">// character in the group</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (numconds == 0)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>char* p = c.conds;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><office:annotation office:name="__Annotation__12474_854338662">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T00:51:50.191396373</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">Iterate through string st and simplified regex condition and report if there is a match or not.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Values neg and ingroup are to process for simplified regex.</text:span></text:p>
      </office:annotation>while (1)<office:annotation-end office:name="__Annotation__12474_854338662"/> {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>switch (*p) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case &apos;\0&apos;:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case &apos;[&apos;: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>neg = false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>ingroup = false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>pos = st;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case &apos;^&apos;: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>neg = true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case &apos;]&apos;: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if ((neg &amp;&amp; ingroup) || (!neg &amp;&amp; !ingroup))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>pos = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/><text:span text:style-name="T2">// skip the next character</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!ingroup &amp;&amp; *st)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>for (st++; (opts &amp; aeUTF8) &amp;&amp; (*st &amp; 0xc0) == 0x80; st++)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (*st == &apos;\0&apos; &amp;&amp; p)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return 0; <text:s/><text:span text:style-name="T2">// word &lt;= condition</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case &apos;.&apos;:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!pos) { <text:s/><text:span text:style-name="T2">// dots are not metacharacters in groups: [.]</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/><text:span text:style-name="T2">// skip the next character</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>for (st++; (opts &amp; aeUTF8) &amp;&amp; (*st &amp; 0xc0) == 0x80; st++)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (*st == &apos;\0&apos; &amp;&amp; p)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>return 0; <text:s/><text:span text:style-name="T2">// word &lt;= condition</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">/* FALLTHROUGH */</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>default: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (*st == *p) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>st++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if ((opts &amp; aeUTF8) &amp;&amp; (*(st - 1) &amp; 0x80)) { <text:s/><text:span text:style-name="T2">// multibyte</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>while (p &amp;&amp; (*p &amp; 0xc0) == 0x80) { <text:s text:c="9"/><text:span text:style-name="T2">// character</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>if (*p != *st) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>if (!pos)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="18"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>st = pos;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>st++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (pos &amp;&amp; st != pos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>ingroup = true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>while (p &amp;&amp; *p != &apos;]&apos; &amp;&amp; ((p = nextchar(p)) != NULL)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>} else if (pos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>ingroup = true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>while (p &amp;&amp; *p != &apos;]&apos; &amp;&amp; ((p = nextchar(p)) != NULL)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>} else if (pos) { <text:s/><text:span text:style-name="T2">// group</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>} else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (!p)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">// check if this prefix entry matches</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">struct hentry* <text:span text:style-name="T1">PfxEntry::checkword</text:span>(const char* word,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="35"/>int len,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="35"/>char in_compound,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="35"/>const FLAG needflag) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>struct hentry* he; <text:s/><text:span text:style-name="T2">// hash entry of root word or NULL</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// on entry prefix is 0 length or already matches the beginning of the word.</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// So if the remaining root word has positive length</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// and if there are enough chars in root word and added back strip chars</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// to meet the number of characters conditions, then test it</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int tmpl = len - appnd.size(); <text:span text:style-name="T2">// length of tmpword</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><office:annotation office:name="__Annotation__2412_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T15:28:10.408621620</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">If this residual length is 0 but the fullstrip option was not set in the affix file.</text:span></text:p>
      </office:annotation>if<office:annotation-end office:name="__Annotation__2412_3738427752"/> (tmpl &gt; 0 || (tmpl == 0 &amp;&amp; pmyMgr-&gt;get_fullstrip())) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// generate new root word by removing prefix and adding</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// back any characters that would have been stripped</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string tmpword(strip);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><office:annotation office:name="__Annotation__2381_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T15:19:31.902272063</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Create a temporary root word by concatenating the strip characters of this prefix and the word that is being checked with an offset of the length of this prefix. This could be called a reverse prefix appending followed by reverse stripping.</text:span></text:p>
      </office:annotation>tmpword<office:annotation-end office:name="__Annotation__2381_3738427752"/>.append(word + appnd.size());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// now make sure all of the conditions on characters</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// are met. <text:s/>Please see the appendix at the end of</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// this file for more info on exactly what is being</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// tested</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// if all conditions are met then check if resulting</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// root word in the dictionary</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (test_condition(tmpword.c_str())) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>tmpl += strip.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((he = pmyMgr-&gt;<text:span text:style-name="T13">lookup</text:span>(tmpword.c_str())) != NULL) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>do {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/><office:annotation office:name="__Annotation__12801_1217202475">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-20T20:21:15.427659447</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">Return hash entry if all of the following applies:</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T14">1) The f</text:span><text:span text:style-name="T15">lag of this prefix is one of the supported flags of the hash entry.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">2) The generic flag to designate forbidden roots may not appear in the list of possible continuing classes for this prefix.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">3) No flag provided to check for. OR The provided flag to check for is one of the supported flags of the hash entry. OR There are possible continuing classes for this prefix and the provided flag to check for is in the possible continuing classes for this prefix.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
      </office:annotation>if<office:annotation-end office:name="__Annotation__12801_1217202475"/> (TESTAFF(he-&gt;astr, aflag, he-&gt;alen) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/><text:span text:style-name="T2">// forbid single prefixes with needaffix flag</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>!TESTAFF(contclass, pmyMgr-&gt;get_needaffix(), contclasslen) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/><text:span text:style-name="T2">// needflag</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>((!needflag) || TESTAFF(he-&gt;astr, needflag, he-&gt;alen) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="15"/>(contclass &amp;&amp; TESTAFF(contclass, needflag, contclasslen))))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>return he;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>he = he-&gt;next_homonym; <text:s/><text:span text:style-name="T2">// check homonyms</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>} while (he);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// prefix matched but no root word was found</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// if aeXPRODUCT is allowed, try again but now</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// ross checked combined with a suffix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// if ((opts &amp; aeXPRODUCT) &amp;&amp; in_compound) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((opts &amp; aeXPRODUCT)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>he = pmyMgr-&gt;<text:span text:style-name="T13">suffix_check</text:span>(tmpword.c_str(), tmpl, aeXPRODUCT, this,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="34"/>FLAG_NULL, needflag, in_compound);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (he)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="10"/>return he;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">// check if this prefix entry matches</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">struct hentry* <text:span text:style-name="T1">PfxEntry::check_twosfx</text:span>(const char* word,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="38"/>int len,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="38"/>char in_compound,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="38"/>const FLAG needflag) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// on entry prefix is 0 length or already matches the beginning of the word.</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// So if the remaining root word has positive length</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// and if there are enough chars in root word and added back strip chars</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// to meet the number of characters conditions, then test it</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int tmpl = len - appnd.size(); // length of tmpword</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if ((tmpl &gt; 0 || (tmpl == 0 &amp;&amp; pmyMgr-&gt;get_fullstrip())) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>(tmpl + strip.size() &gt;= numconds)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// generate new root word by removing prefix and adding</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// back any characters that would have been stripped</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string tmpword(strip);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><office:annotation office:name="__Annotation__2456_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T15:37:12.820711286</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Create a temporary root word by concatenating the strip characters of this prefix and the word that is being checked with an offset of the length of this prefix. This could be called a reverse prefix appending followed by reverse stripping.</text:span></text:p>
      </office:annotation>tmpword<office:annotation-end office:name="__Annotation__2456_3738427752"/>.append(word + appnd.size());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// now make sure all of the conditions on characters</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// are met. <text:s/>Please see the appendix at the end of</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// this file for more info on exactly what is being</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// tested</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// if all conditions are met then check if resulting</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// root word in the dictionary</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (test_condition(tmpword.c_str())) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>tmpl += strip.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// prefix matched but no root word was found</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// if aeXPRODUCT is allowed, try again but now</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// cross checked combined with a suffix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((opts &amp; aeXPRODUCT) &amp;&amp; (in_compound != IN_CPD_BEGIN)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/><text:span text:style-name="T2">// hash entry of root word or NULL</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>struct hentry* he = pmyMgr-&gt;<text:span text:style-name="T13">suffix_check_twosfx</text:span>(tmpword.c_str(), tmpl, aeXPRODUCT, this,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="56"/>needflag);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (he)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return he;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">// check if this prefix entry matches</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::string <text:span text:style-name="T1">PfxEntry::check_twosfx_morph</text:span>(const char* word,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="41"/>int len,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="41"/>char in_compound,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="41"/>const FLAG needflag) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// on entry prefix is 0 length or already matches the beginning of the word.</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// So if the remaining root word has positive length</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// and if there are enough chars in root word and added back strip chars</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// to meet the number of characters conditions, then test it</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>int tmpl = len - appnd.size(); // length of tmpword</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if ((tmpl &gt; 0 || (tmpl == 0 &amp;&amp; pmyMgr-&gt;get_fullstrip())) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>(tmpl + strip.size() &gt;= numconds)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// generate new root word by removing prefix and adding</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// back any characters that would have been stripped</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string tmpword(strip);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><office:annotation office:name="__Annotation__2457_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T15:37:21.156875983</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Create a temporary root word by concatenating the strip characters of this prefix and the word that is being checked with an offset of the length of this prefix. This could be called a reverse prefix appending followed by reverse stripping.</text:span></text:p>
      </office:annotation>tmpword<office:annotation-end office:name="__Annotation__2457_3738427752"/>.append(word + appnd.size());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// now make sure all of the conditions on characters</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// are met. <text:s/>Please see the appendix at the end of</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// this file for more info on exactly what is being</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// tested</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// if all conditions are met then check if resulting</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// root word in the dictionary</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (test_condition(tmpword.c_str())) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>tmpl += strip.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// prefix matched but no root word was found</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// if aeXPRODUCT is allowed, try again but now</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// ross checked combined with a suffix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><office:annotation office:name="__Annotation__13350_3129959820">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-03-02T16:10:21.467056049</dc:date>
       <text:p/>
      </office:annotation>if<office:annotation-end office:name="__Annotation__13350_3129959820"/> ((opts &amp; aeXPRODUCT) &amp;&amp; (in_compound != IN_CPD_BEGIN)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>result = pmyMgr-&gt;<text:span text:style-name="T13">suffix_check_twosfx_morph</text:span>(tmpword.c_str(), tmpl,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="51"/>aeXPRODUCT,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="51"/>this, needflag);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">// check if this prefix entry matches</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::string <text:span text:style-name="T1">PfxEntry::check_morph</text:span>(const char* word,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="34"/>int len,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="34"/>char in_compound,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="34"/>const FLAG needflag) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P6"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P6"><text:s text:c="2"/><text:span text:style-name="T2">// on entry prefix is 0 length or already matches the beginning of the word.</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P6"><text:s text:c="2"/><text:span text:style-name="T2">// So if the remaining root word has positive length</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P6"><text:s text:c="2"/><text:span text:style-name="T2">// and if there are enough chars in root word and added back strip chars</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P6"><text:s text:c="2"/><text:span text:style-name="T2">// to meet the number of characters conditions, then test it</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P6"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:span text:style-name="T10"><text:s text:c="2"/>int tmpl = len - appnd.si</text:span>ze(); // length of tmpword</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if ((tmpl &gt; 0 || (tmpl == 0 &amp;&amp; pmyMgr-&gt;get_fullstrip())) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>(tmpl + strip.size() &gt;= numconds)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// generate new root word by removing prefix and adding</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// back any characters that would have been stripped</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string tmpword(strip);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><office:annotation office:name="__Annotation__2455_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T15:36:50.100265572</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Create a temporary root word by concatenating the strip characters of this prefix and the word that is being checked with an offset of the length of this prefix. This could be called a reverse prefix appending followed by reverse stripping.</text:span></text:p>
      </office:annotation>tmpword<office:annotation-end office:name="__Annotation__2455_3738427752"/>.append(word + appnd.size());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// now make sure all of the conditions on characters</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// are met. <text:s/>Please see the appendix at the end of</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// this file for more info on exactly what is being</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// tested</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// if all conditions are met then check if resulting</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// root word in the dictionary</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>if (test_condition(tmpword.c_str())) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>tmpl += strip.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>struct hentry* he; <text:s/><text:span text:style-name="T2">// hash entry of root word or NULL</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((he = pmyMgr-&gt;<text:span text:style-name="T13">lookup</text:span>(tmpword.c_str())) != NULL) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>do {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/><office:annotation office:name="__Annotation__13004_2659974304">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-21T11:47:57.971729333</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">If all of the following conditions apply:</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">1) The flag of this prefix is one of the supported flags of the hash entry.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">2) The generic flag to designate forbidden roots may not appear in the list of possible continuing classes for this prefix.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">3) No flag is provided to check for. OR The provided flag to check for is one of the supported flags of the hash entry. OR There are possible continuing classes for this prefix and the provided flag to check for is in the possible continuing classes for this prefix</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
      </office:annotation>if<office:annotation-end office:name="__Annotation__13004_2659974304"/> (TESTAFF(he-&gt;astr, aflag, he-&gt;alen) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/><text:span text:style-name="T2">// forbid single prefixes with needaffix flag</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>!TESTAFF(contclass, pmyMgr-&gt;get_needaffix(), contclasslen) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/><text:span text:style-name="T2">// needflag</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>((!needflag) || TESTAFF(he-&gt;astr, needflag, he-&gt;alen) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="15"/>(contclass &amp;&amp; TESTAFF(contclass, needflag, contclasslen)))) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (morphcode) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(&quot; &quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(morphcode);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>} else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(getKey());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (!HENTRY_FIND(he, MORPH_STEM)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(&quot; &quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(MORPH_STEM);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(HENTRY_WORD(he));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/><text:span text:style-name="T2">// store the pointer of the hash entry</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (HENTRY_DATA(he)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(&quot; &quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(HENTRY_DATA2(he));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/><text:span text:style-name="T2">// return with debug information</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>char* flag = pmyMgr-&gt;encode_flag(getFlag());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(&quot; &quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(MORPH_FLAG);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(flag);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>free(flag);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>result.append(&quot;\n&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>he = he-&gt;next_homonym;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>} while (he);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// prefix matched but no root word was found</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// if aeXPRODUCT is allowed, try again but now</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// ross checked combined with a suffix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((opts &amp; aeXPRODUCT) &amp;&amp; (in_compound != IN_CPD_BEGIN)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string st = pmyMgr-&gt;<text:span text:style-name="T13">suffix_check_morph</text:span>(tmpword.c_str(), tmpl, aeXPRODUCT, this,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="52"/>FLAG_NULL, needflag);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!st.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>result.append(st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:span text:style-name="T1">SfxEntry::SfxEntry</text:span>(AffixMgr* pmgr)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>: pmyMgr(pmgr) <text:s/><text:span text:style-name="T2">// register affix manager</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>next(NULL),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>nexteq(NULL),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>nextne(NULL),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>flgnxt(NULL),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>l_morph(NULL),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="6"/>r_morph(NULL),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>eq_morph(NULL) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">// add suffix to this word assuming conditions hold</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::string <text:span text:style-name="T1">SfxEntry::add</text:span>(const char* word, size_t len) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">/* make sure all conditions match */</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>i<office:annotation office:name="__Annotation__12848_1217202475">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-20T20:27:41.986866981</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">QUESTION: We do not do this in implementation Nuspell as we delegate this to the parsing method for performance reasons. Is that safe enough? Do we check all this in the parsing? TODO Double check this.</text:span></text:p>
      </office:annotation>f<office:annotation-end office:name="__Annotation__12848_1217202475"/> ((len &gt; strip.size() || (len == 0 &amp;&amp; pmyMgr-&gt;get_fullstrip())) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>(len &gt;= numconds) &amp;&amp; test_condition(word + len, word) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>(!strip.size() ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="7"/>(strcmp(word + len - strip.size(), strip.c_str()) == 0))) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>result.assign(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">/* we have a match so add suffix */</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>result.replace(len - strip.size(), std::string::npos, appnd);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">inline char* <text:span text:style-name="T1">SfxEntry::nextchar</text:span>(char* p) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (p) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>p++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (opts &amp; aeLONGCOND) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// jump to the 2nd part of the condition</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (p == c.l.conds1 + MAXCONDLEN_1)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return c.l.conds2;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">// end of the MAXCONDLEN length condition</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else if (p == c.conds + MAXCONDLEN)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return *p ? p : NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">inline <office:annotation office:name="__Annotation__12394_854338662">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T00:28:19.792235914</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">Return value is only 0 or 1</text:span></text:p>
      </office:annotation>int<office:annotation-end office:name="__Annotation__12394_854338662"/> <text:span text:style-name="T1">SfxEntry::</text:span><office:annotation office:name="__Annotation__12610_854338662">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T01:27:02.725148976</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Called by:</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">- add</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">- checkword</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">- check_twosfx</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">- check_twosfx_morph</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Good testcase is condition.aff</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Similar method exists for prefix entry.</text:span></text:p>
      </office:annotation><text:span text:style-name="T1">test_condition</text:span><office:annotation-end office:name="__Annotation__12610_854338662"/>(const char* st, const char* beg) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* pos = NULL; <text:s/><text:span text:style-name="T2">// group with pos input position</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>bool neg = false; <text:s text:c="7"/><text:span text:style-name="T2">// complementer</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>bool ingroup = false; <text:s text:c="3"/><text:span text:style-name="T2">// character in the group</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (numconds == 0)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>char* p = <office:annotation office:name="__Annotation__12395_854338662">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T00:31:12.324216349</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">Attribute of affix entry which holds union of a single condition or a pair of conditions. This implementation is only a C-style optimization.</text:span></text:p>
      </office:annotation>c<office:annotation-end office:name="__Annotation__12395_854338662"/>.conds;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>st--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int i = 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><office:annotation office:name="__Annotation__12475_854338662">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T00:53:22.657420155</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Iterate through string st and simplified regex condition and report if there is a match or not.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Values neg and ingroup are to process for simplified regex.</text:span></text:p>
      </office:annotation>while (1)<office:annotation-end office:name="__Annotation__12475_854338662"/> {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>switch (*p) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case &apos;\0&apos;:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case &apos;[&apos;:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>pos = st;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case &apos;^&apos;:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>neg = true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case &apos;]&apos;:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!neg &amp;&amp; !ingroup)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>i++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/><text:span text:style-name="T2">// skip the next character</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!ingroup) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>for (; (opts &amp; aeUTF8) &amp;&amp; (st &gt;= beg) &amp;&amp; (*st &amp; 0xc0) == 0x80; st--)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>st--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="8"/>pos = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>neg = false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>ingroup = false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (st &lt; beg &amp;&amp; p)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return 0; <text:s/><text:span text:style-name="T2">// word &lt;= condition</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case &apos;.&apos;:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!pos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/><text:span text:style-name="T2">// dots are not metacharacters in groups: [.]</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/><text:span text:style-name="T2">// skip the next character</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>for (st--; (opts &amp; aeUTF8) &amp;&amp; (st &gt;= beg) &amp;&amp; (*st &amp; 0xc0) == 0x80;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="15"/>st--)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (st &lt; beg) { <text:s/><text:span text:style-name="T2">// word &lt;= condition</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (p)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if ((opts &amp; aeUTF8) &amp;&amp; (*st &amp; 0x80)) { <text:s/>// head of the UTF-8 character</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>st--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (st &lt; beg) { <text:s/><text:span text:style-name="T2">// word &lt;= condition</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>if (p)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><text:span text:style-name="T2">/* FALLTHROUGH */</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>default: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (*st == *p) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if ((opts &amp; aeUTF8) &amp;&amp; (*st &amp; 0x80)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>st--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>while (p &amp;&amp; (st &gt;= beg)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>if (*p != *st) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>if (!pos)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="18"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>st = pos;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/><text:span text:style-name="T2">// first byte of the UTF-8 multibyte character</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>if ((*p &amp; 0xc0) != 0x80)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>st--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (pos &amp;&amp; st != pos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>if (neg)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>else if (i == numconds)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>ingroup = true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>while (p &amp;&amp; *p != &apos;]&apos; &amp;&amp; ((p = nextchar(p)) != NULL)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>st--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (p &amp;&amp; *p != &apos;]&apos;)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>} else if (pos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (neg)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="14"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>else if (i == numconds)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>ingroup = true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>while (p &amp;&amp; *p != &apos;]&apos; &amp;&amp; ((p = nextchar(p)) != NULL)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/><text:span text:style-name="T3">//<text:tab/><text:tab/><text:tab/>if (p &amp;&amp; *p != &apos;]&apos;) p = nextchar(p);</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>st--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (!pos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>i++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>st--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (st &lt; beg &amp;&amp; p &amp;&amp; *p != &apos;]&apos;)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>return 0; <text:s text:c="5"/><text:span text:style-name="T2">// word &lt;= condition</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>} else if (pos) { <text:s/><text:span text:style-name="T2">// group</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>p = nextchar(p);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>} else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (!p)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">// see if this suffix is present in the word</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">struct hentry* <text:span text:style-name="T1">SfxEntry::checkword</text:span>(const char* word,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="35"/>int len,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="35"/>int optflags,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="35"/>PfxEntry* ppfx,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="35"/>const FLAG cclass,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="35"/>const FLAG needflag,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="35"/>const FLAG badflag) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>struct hentry* he; <text:s/><text:span text:style-name="T2">// hash entry pointer</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>PfxEntry* ep = ppfx;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// if this suffix is being cross checked with a prefix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// but it does not support cross products skip it</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (((<office:annotation office:name="__Annotation__2344_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T15:04:51.947547343</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">TODO: what is in here?</text:span></text:p>
      </office:annotation>optflags<office:annotation-end office:name="__Annotation__2344_3738427752"/> &amp; aeXPRODUCT) != 0) &amp;&amp; ((<office:annotation office:name="__Annotation__2345_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T15:05:15.675559870</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T14">Options from this suffix</text:span></text:p>
      </office:annotation>opts<office:annotation-end office:name="__Annotation__2345_3738427752"/> &amp; aeXPRODUCT) == 0))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// upon entry suffix is 0 length or already matches the end of the word.</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// So if the remaining root word has positive length</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// and if there are enough chars in root word and added back strip chars</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// to meet the number of characters conditions, then test it</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int tmpl = len - appnd.size(); // length of tmpword</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// the second condition is not enough for UTF-8 strings</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// it checked in test_condition()</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if ((tmpl &gt; 0 || (tmpl == 0 &amp;&amp; pmyMgr-&gt;get_fullstrip())) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>(tmpl + strip.size() &gt;= numconds)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// generate new root word by removing suffix and adding</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// back any characters that would have been stripped or</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// or null terminating the shorter string</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string tmpstring(word, tmpl);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (strip.size()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>tmpstring.append(strip);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>const char* tmpword = tmpstring.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>const char* endword = tmpword + tmpstring.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// now make sure all of the conditions on characters</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// are met. <text:s/>Please see the appendix at the end of</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// this file for more info on exactly what is being</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// tested</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// if all conditions are met then check if resulting</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// root word in the dictionary</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (test_condition(endword, tmpword)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#ifdef SZOSZABLYA_POSSIBLE_ROOTS</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>fprintf(stdout, &quot;%s %s %c\n&quot;, word, tmpword, aflag);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#endif</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((he = pmyMgr-&gt;<text:span text:style-name="T13">lookup</text:span>(tmpword)) != NULL) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>do {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/><text:span text:style-name="T2">// check conditional suffix (enabled by prefix)</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/><office:annotation office:name="__Annotation__2316_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T14:58:52.803516481</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Return hash entry if all of the following applies:</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">1) The flag of this suffix entry is one of the supported flags of the hash entry. OR A prefix entry with continuing classes has been provided and the flag of this suffix entry is in the possible continuing classes of that prefix entry.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">2) This suffix entry does not support cross product. OR A prefix entry has been provided which flag is on of the supported flags of the hash entry. OR This suffix entry has possible continuing classes the provided prefix entry has a flag that is in those continuing classes.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">3) No continuing class flag is provided to check for. OR There are possible continuing classes for this suffix entry and the provided continuing class flag to check for is in the possible continuing classes for this suffix entry.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">4) No bad flag is provided to check for. OR The provided bad flag to check for <text:s/>is not one of the supported flags of the hash entry.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">5) No flag is provided to check for. OR The provided flag to check for is one of the supported flags of the hash entry. OR There are possible continuing classes for this suffix entry and the provided flag to check for is in the possible continuing classes for this suffix.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
      </office:annotation>if<office:annotation-end office:name="__Annotation__2316_3738427752"/> ((TESTAFF(he-&gt;astr, aflag, he-&gt;alen) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="15"/>(ep &amp;&amp; ep-&gt;getCont() &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>TESTAFF(ep-&gt;getCont(), aflag, ep-&gt;getContLen()))) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>(((optflags &amp; aeXPRODUCT) == 0) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="15"/>(ep &amp;&amp; TESTAFF(he-&gt;astr, ep-&gt;getFlag(), he-&gt;alen)) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="15"/><text:span text:style-name="T2">// enabled by prefix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="15"/>((contclass) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>(ep &amp;&amp; TESTAFF(contclass, ep-&gt;getFlag(), contclasslen)))) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/><text:span text:style-name="T2">// handle cont. class</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>((!cclass) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="15"/>((contclass) &amp;&amp; TESTAFF(contclass, cclass, contclasslen))) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/><text:span text:style-name="T2">// check only in compound homonyms (bad flags)</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>(!badflag || !TESTAFF(he-&gt;astr, badflag, he-&gt;alen)) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/><text:span text:style-name="T2">// handle required flag</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>((!needflag) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="15"/>(TESTAFF(he-&gt;astr, needflag, he-&gt;alen) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>((contclass) &amp;&amp; TESTAFF(contclass, needflag, contclasslen)))))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>return he;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>he = he-&gt;next_homonym; <text:s/><text:span text:style-name="T2">// check homonyms</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>} while (he);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">// see if two-level suffix is present in the word</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">struct hentry* <text:span text:style-name="T1">SfxEntry::check_twosfx</text:span>(const char* word,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="38"/>int len,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="38"/>int optflags,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="38"/>PfxEntry* ppfx,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="38"/>const FLAG needflag) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>PfxEntry* ep = ppfx;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// if this suffix is being cross checked with a prefix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// but it does not support cross products skip it</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if ((optflags &amp; aeXPRODUCT) != 0 &amp;&amp; (opts &amp; aeXPRODUCT) == 0)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// upon entry suffix is 0 length or already matches the end of the word.</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// So if the remaining root word has positive length</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// and if there are enough chars in root word and added back strip chars</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// to meet the number of characters conditions, then test it</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int tmpl = len - appnd.size(); <text:span text:style-name="T2">// length of tmpword</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if ((tmpl &gt; 0 || (tmpl == 0 &amp;&amp; pmyMgr-&gt;get_fullstrip())) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>(tmpl + strip.size() &gt;= numconds)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/><text:span text:style-name="T2">// generate new root word by removing suffix and adding</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// back any characters that would have been stripped or</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// or null terminating the shorter string</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string tmpword(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>tmpword.resize(tmpl);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>tmpword.append(strip);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>tmpl += strip.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>const char* beg = tmpword.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>const char* end = beg + tmpl;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// now make sure all of the conditions on characters</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// are met. <text:s/>Please see the appendix at the end of</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// this file for more info on exactly what is being</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// tested</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// if all conditions are met then recall suffix_check</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (test_condition(end, beg)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>struct hentry* he; <text:s/><text:span text:style-name="T2">// hash entry pointer</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (ppfx) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/><text:span text:style-name="T2">// handle conditional suffix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/><office:annotation office:name="__Annotation__2460_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T15:38:37.318337195</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">All of the following must apply:</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">1) This suffix entry has possible continuning classes.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">2) The flag of the provided prefix entry can be found in the continuning classes of this suffix entry.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
      </office:annotation>if<office:annotation-end office:name="__Annotation__2460_3738427752"/> ((contclass) &amp;&amp; TESTAFF(contclass, ep-&gt;getFlag(), contclasslen))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>he = pmyMgr-&gt;<text:span text:style-name="T13">suffix_check</text:span>(tmpword.c_str(), tmpl, 0, NULL,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="36"/>(FLAG)aflag, needflag, IN_CPD_NOT);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>he = pmyMgr-&gt;<text:span text:style-name="T13">suffix_check</text:span>(tmpword.c_str(), tmpl, optflags, ppfx,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="36"/>(FLAG)aflag, needflag, IN_CPD_NOT);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>he = pmyMgr-&gt;<text:span text:style-name="T13">suffix_check</text:span>(tmpword.c_str(), tmpl, 0, NULL,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="34"/>(FLAG)aflag, needflag, IN_CPD_NOT);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (he)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return he;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">// see if two-level suffix is present in the word</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::string <text:span text:style-name="T1">SfxEntry::check_twosfx_morph</text:span>(const char* word,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="41"/>int len,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="41"/>int optflags,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="41"/>PfxEntry* ppfx,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="41"/>const FLAG needflag) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>PfxEntry* ep = ppfx;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// if this suffix is being cross checked with a prefix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// but it does not support cross products skip it</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if ((optflags &amp; aeXPRODUCT) != 0 &amp;&amp; (opts &amp; aeXPRODUCT) == 0)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// upon entry suffix is 0 length or already matches the end of the word.</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// So if the remaining root word has positive length</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// and if there are enough chars in root word and added back strip chars</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><text:span text:style-name="T2">// to meet the number of characters conditions, then test it</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int tmpl = len - appnd.size(); // length of tmpword</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if ((tmpl &gt; 0 || (tmpl == 0 &amp;&amp; pmyMgr-&gt;get_fullstrip())) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>(tmpl + strip.size() &gt;= numconds)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/><text:span text:style-name="T2">// generate new root word by removing suffix and adding</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// back any characters that would have been stripped or</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// or null terminating the shorter string</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string tmpword(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>tmpword.resize(tmpl);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>tmpword.append(strip);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>tmpl += strip.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>const char* beg = tmpword.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>const char* end = beg + tmpl;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// now make sure all of the conditions on characters</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// are met. <text:s/>Please see the appendix at the end of</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// this file for more info on exactly what is being</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// tested</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><text:span text:style-name="T2">// if all conditions are met then recall suffix_check</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (test_condition(end, beg)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (ppfx) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/><text:span text:style-name="T2">// handle conditional suffix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/><office:annotation office:name="__Annotation__13488_2659974304">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-21T15:20:11.653792134</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">All of the following must apply:</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">1) This suffix entry has possible continuning classes.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">2) The flag of the provided prefix entry can be found in the continuning classes of this suffix entry.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
      </office:annotation>if<office:annotation-end office:name="__Annotation__13488_2659974304"/> ((contclass) &amp;&amp; TESTAFF(contclass, ep-&gt;getFlag(), contclasslen)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>std::string st = pmyMgr-&gt;<text:span text:style-name="T13">suffix_check_morph</text:span>(tmpword.c_str(), tmpl, 0, NULL, aflag,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="54"/>needflag);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (!st.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (ppfx-&gt;getMorph()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(ppfx-&gt;getMorph());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>result.append(&quot; &quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>result.append(st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>mychomp(result);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>std::string st = pmyMgr-&gt;<text:span text:style-name="T13">suffix_check_morph</text:span>(tmpword.c_str(), tmpl, optflags, ppfx, aflag,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="54"/>needflag);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (!st.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>result.append(st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>mychomp(result);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string st = pmyMgr-&gt;<text:span text:style-name="T13">suffix_check_morph</text:span>(tmpword.c_str(), tmpl, 0, NULL, aflag, needflag);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!st.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>result.append(st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>mychomp(result);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">// get next homonym with same affix</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">struct hentry* <text:span text:style-name="T1">SfxEntry::get_next_homonym</text:span>(struct hentry* he,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="42"/>int optflags,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="42"/>PfxEntry* ppfx,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="42"/>const FLAG cclass,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="42"/>const FLAG needflag) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>PfxEntry* ep = ppfx;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>FLAG eFlag = ep ? ep-&gt;getFlag() : FLAG_NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>while (he-&gt;next_homonym) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>he = he-&gt;next_homonym;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/><office:annotation office:name="__Annotation__2315_3738427752">
       <dc:creator>Unknown Author</dc:creator>
       <dc:date>2018-02-15T14:55:06.624076553</dc:date>
       <text:p text:style-name="P7"><text:span text:style-name="T15">Return hash entry if al off the following conditons apply:</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">1) The flag of this suffix entry is one of the supported flags of the hash entry. OR A prefix entry with continuing classes has been provided and the flag of this suffix entry is in the possible continuing classes of that prefix entry.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">2) This suffix entry does not support cross product. OR A prefix entry has been provided which flag is on of the supported flags of the hash entry. OR This suffix entry has possible continuing classes the provided prefix entry has a flag that is in those continuing classes.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">3) No continuing class flag is provided to check for. OR There are possible continuing classes for this suffix entry and the provided continuing class flag to check for is in the possible continuing classes for this suffix entry.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">4) No bad flag is provided to check for. OR The provided bad flag to check for <text:s/>is not one of the supported flags of the hash entry.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15">5) No flag is provided to check for. OR The provided flag to check for is one of the supported flags of the hash entry OR there are possible continuing classes for this suffix entry and the provided flag to check for is in the possible continuing classes for this suffix.</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T15"/></text:p>
      </office:annotation>if<office:annotation-end office:name="__Annotation__2315_3738427752"/> ((TESTAFF(he-&gt;astr, aflag, he-&gt;alen) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="9"/>(ep &amp;&amp; ep-&gt;getCont() &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>TESTAFF(ep-&gt;getCont(), aflag, ep-&gt;getContLen()))) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>((optflags &amp; aeXPRODUCT) == 0 || TESTAFF(he-&gt;astr, eFlag, he-&gt;alen) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="9"/><text:span text:style-name="T2">// handle conditional suffix</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="9"/>((contclass) &amp;&amp; TESTAFF(contclass, eFlag, contclasslen))) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/><text:span text:style-name="T2">// handle cont. class</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>((!cclass) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="9"/>((contclass) &amp;&amp; TESTAFF(contclass, cclass, contclasslen))) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/><text:span text:style-name="T2">// handle required flag</text:span></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>((!needflag) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="9"/>(TESTAFF(he-&gt;astr, needflag, he-&gt;alen) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>((contclass) &amp;&amp; TESTAFF(contclass, needflag, contclasslen)))))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return he;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">void <text:span text:style-name="T1">SfxEntry::initReverseWord</text:span>() {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>rappnd = appnd;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>reverseword(rappnd);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#if 0</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">Appendix: <text:s/>Understanding Affix Code</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">An affix is either a <text:s/>prefix or a suffix attached to root words to make </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">other words.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">Basically a Prefix or a Suffix is set of AffEntry objects</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">which store information about the prefix or suffix along </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">with supporting routines to check if a word has a particular </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">prefix or suffix or a combination.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">The structure affentry is defined as follows:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">struct affentry</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">{</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="3"/>unsigned short aflag; <text:s text:c="3"/>// ID used to represent the affix</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="3"/>std::string strip; <text:s text:c="6"/>// string to strip before adding affix</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="3"/>std::string appnd; <text:s text:c="6"/>// the affix string to add</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="3"/>char numconds; <text:s text:c="10"/>// the number of conditions that must be met</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="3"/>char opts; <text:s text:c="14"/>// flag: aeXPRODUCT- combine both prefix and suffix </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="3"/>char <text:s text:c="2"/>conds[SETSIZE]; <text:s text:c="2"/>// array which encodes the conditions to be met</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">};</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">Here is a suffix borrowed from the en_US.aff file. <text:s/>This file </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">is whitespace delimited.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">SFX D Y 4 </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">SFX D <text:s text:c="2"/>0 <text:s text:c="4"/>e <text:s text:c="9"/>d</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">SFX D <text:s text:c="2"/>y <text:s text:c="4"/>ied <text:s text:c="7"/>[^aeiou]y</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">SFX D <text:s text:c="2"/>0 <text:s text:c="4"/>ed <text:s text:c="8"/>[^ey]</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">SFX D <text:s text:c="2"/>0 <text:s text:c="4"/>ed <text:s text:c="8"/>[aeiou]y</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">This information can be interpreted as follows:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">In the first line has 4 fields</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">Field</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:soft-page-break/>-----</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">1 <text:s text:c="4"/>SFX - indicates this is a suffix</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">2 <text:s text:c="4"/>D <text:s text:c="2"/>- is the name of the character flag which represents this suffix</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">3 <text:s text:c="4"/>Y <text:s text:c="2"/>- indicates it can be combined with prefixes (cross product)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">4 <text:s text:c="4"/>4 <text:s text:c="2"/>- indicates that sequence of 4 affentry structures are needed to</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="15"/>properly store the affix information</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">The remaining lines describe the unique information for the 4 SfxEntry </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">objects that make up this affix. <text:s/>Each line can be interpreted</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">as follows: (note fields 1 and 2 are as a check against line 1 info)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">Field</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">-----</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">1 <text:s text:c="4"/>SFX <text:s text:c="8"/>- indicates this is a suffix</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">2 <text:s text:c="4"/>D <text:s text:c="10"/>- is the name of the character flag for this affix</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">3 <text:s text:c="4"/>y <text:s text:c="10"/>- the string of chars to strip off before adding affix</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="25"/>(a 0 here indicates the NULL string)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">4 <text:s text:c="4"/>ied <text:s text:c="8"/>- the string of affix characters to add</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">5 <text:s text:c="4"/>[^aeiou]y <text:s text:c="2"/>- the conditions which must be met before the affix</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="20"/>can be applied</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">Field 5 is interesting. <text:s/>Since this is a suffix, field 5 tells us that</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">there are 2 conditions that must be met. <text:s/>The first condition is that </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">the next to the last character in the word must *NOT* be any of the </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">following &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot; or &quot;u&quot;. <text:s/>The second condition is that</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">the last character of the word must end in &quot;y&quot;.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">So how can we encode this information concisely and be able to </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">test for both conditions in a fast manner? <text:s/>The answer is found</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">but studying the wonderful ispell code of Geoff Kuenning, et.al. </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">(now available under a normal BSD license).</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">If we set up a conds array of 256 bytes indexed (0 to 255) and access it</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">using a character (cast to an unsigned char) of a string, we have 8 bits</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">of information we can store about that character. <text:s/>Specifically we</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">could use each bit to say if that character is allowed in any of the </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">last (or first for prefixes) 8 characters of the word.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">Basically, each character at one end of the word (up to the number </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">of conditions) is used to index into the conds array and the resulting </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">value found there says whether the that character is valid for a </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">specific character position in the word. <text:s/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">For prefixes, it does this by setting bit 0 if that char is valid </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">in the first position, bit 1 if valid in the second position, and so on. </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">If a bit is not set, then that char is not valid for that postion in the</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">word.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">If working with suffixes bit 0 is used for the character closest </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">to the front, bit 1 for the next character towards the end, ..., </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">with bit numconds-1 representing the last char at the end of the string. </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">Note: since entries in the conds[] are 8 bits, only 8 conditions </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">(read that only 8 character positions) can be examined at one</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">end of a word (the beginning for prefixes and the end for suffixes.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">So to make this clearer, lets encode the conds array values for the </text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">first two affentries for the suffix D described earlier.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="2"/>For the first affentry: <text:s text:c="3"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="5"/>numconds = 1 <text:s text:c="12"/>(only examine the last character)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="5"/>conds[&apos;e&apos;] = <text:s/>(1 &lt;&lt; 0) <text:s text:c="2"/>(the word must end in an E)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:soft-page-break/><text:s text:c="5"/>all others are all 0</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="2"/>For the second affentry:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="5"/>numconds = 2 <text:s text:c="12"/>(only examine the last two characters) <text:s text:c="4"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="5"/>conds[X] = conds[X] | (1 &lt;&lt; 0) <text:s text:c="4"/>(aeiou are not allowed)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="9"/>where X is all characters *but* a, e, i, o, or u</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="9"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="5"/>conds[&apos;y&apos;] = (1 &lt;&lt; 1) <text:s text:c="4"/>(the last char must be a y)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5"><text:s text:c="5"/>all other bits for all other entries in the conds array are zero</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#endif</text:p>
    </text:list-item>
   </text:list>
  </office:text>
 </office:body>
</office:document>