<?xml version="1.0" encoding="UTF-8"?>

<office:document xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0" xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:number="urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0" xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0" xmlns:chart="urn:oasis:names:tc:opendocument:xmlns:chart:1.0" xmlns:dr3d="urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:form="urn:oasis:names:tc:opendocument:xmlns:form:1.0" xmlns:script="urn:oasis:names:tc:opendocument:xmlns:script:1.0" xmlns:config="urn:oasis:names:tc:opendocument:xmlns:config:1.0" xmlns:ooo="http://openoffice.org/2004/office" xmlns:ooow="http://openoffice.org/2004/writer" xmlns:oooc="http://openoffice.org/2004/calc" xmlns:dom="http://www.w3.org/2001/xml-events" xmlns:xforms="http://www.w3.org/2002/xforms" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rpt="http://openoffice.org/2005/report" xmlns:of="urn:oasis:names:tc:opendocument:xmlns:of:1.2" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:grddl="http://www.w3.org/2003/g/data-view#" xmlns:officeooo="http://openoffice.org/2009/office" xmlns:tableooo="http://openoffice.org/2009/table" xmlns:drawooo="http://openoffice.org/2010/draw" xmlns:calcext="urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0" xmlns:loext="urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0" xmlns:field="urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0" xmlns:formx="urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0" xmlns:css3t="http://www.w3.org/TR/css3-text/" office:version="1.2" office:mimetype="application/vnd.oasis.opendocument.text">
 <office:meta><dc:date>2018-01-15T22:42:54.059843639</dc:date><meta:editing-duration>PT32M18S</meta:editing-duration><meta:editing-cycles>8</meta:editing-cycles><meta:generator>LibreOffice/5.4.2.2$Linux_X86_64 LibreOffice_project/40m0$Build-2</meta:generator><meta:document-statistic meta:table-count="0" meta:image-count="0" meta:object-count="0" meta:page-count="33" meta:paragraph-count="2110" meta:word-count="9128" meta:character-count="66239" meta:non-whitespace-character-count="52294"/></office:meta>
 <office:settings>
  <config:config-item-set config:name="ooo:view-settings">
   <config:config-item config:name="ViewAreaTop" config:type="long">186478</config:config-item>
   <config:config-item config:name="ViewAreaLeft" config:type="long">0</config:config-item>
   <config:config-item config:name="ViewAreaWidth" config:type="long">30058</config:config-item>
   <config:config-item config:name="ViewAreaHeight" config:type="long">22147</config:config-item>
   <config:config-item config:name="ShowRedlineChanges" config:type="boolean">true</config:config-item>
   <config:config-item config:name="InBrowseMode" config:type="boolean">false</config:config-item>
   <config:config-item-map-indexed config:name="Views">
    <config:config-item-map-entry>
     <config:config-item config:name="ViewId" config:type="string">view2</config:config-item>
     <config:config-item config:name="ViewLeft" config:type="long">16607</config:config-item>
     <config:config-item config:name="ViewTop" config:type="long">193204</config:config-item>
     <config:config-item config:name="VisibleLeft" config:type="long">0</config:config-item>
     <config:config-item config:name="VisibleTop" config:type="long">186478</config:config-item>
     <config:config-item config:name="VisibleRight" config:type="long">30057</config:config-item>
     <config:config-item config:name="VisibleBottom" config:type="long">208624</config:config-item>
     <config:config-item config:name="ZoomType" config:type="short">0</config:config-item>
     <config:config-item config:name="ViewLayoutColumns" config:type="short">1</config:config-item>
     <config:config-item config:name="ViewLayoutBookMode" config:type="boolean">false</config:config-item>
     <config:config-item config:name="ZoomFactor" config:type="short">100</config:config-item>
     <config:config-item config:name="IsSelectedFrame" config:type="boolean">false</config:config-item>
     <config:config-item config:name="AnchoredTextOverflowLegacy" config:type="boolean">false</config:config-item>
    </config:config-item-map-entry>
   </config:config-item-map-indexed>
  </config:config-item-set>
  <config:config-item-set config:name="ooo:configuration-settings">
   <config:config-item config:name="PrintPaperFromSetup" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintFaxName" config:type="string"/>
   <config:config-item config:name="PrintSingleJobs" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintProspectRTL" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintProspect" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintReversed" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintTextPlaceholder" config:type="boolean">false</config:config-item>
   <config:config-item config:name="DoNotJustifyLinesWithManualBreak" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AlignTabStopPosition" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintLeftPages" config:type="boolean">true</config:config-item>
   <config:config-item config:name="IgnoreFirstLineIndentInNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrinterSetup" config:type="base64Binary"/>
   <config:config-item config:name="CollapseEmptyCellPara" config:type="boolean">true</config:config-item>
   <config:config-item config:name="RedlineProtectionKey" config:type="base64Binary"/>
   <config:config-item config:name="UseOldPrinterMetrics" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UseOldNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AddExternalLeading" config:type="boolean">true</config:config-item>
   <config:config-item config:name="TreatSingleColumnBreakAsPageBreak" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UpdateFromTemplate" config:type="boolean">true</config:config-item>
   <config:config-item config:name="IsLabelDocument" config:type="boolean">false</config:config-item>
   <config:config-item config:name="RsidRoot" config:type="int">1830901</config:config-item>
   <config:config-item config:name="ConsiderTextWrapOnObjPos" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TableRowKeep" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TabsRelativeToIndent" config:type="boolean">true</config:config-item>
   <config:config-item config:name="SaveVersionOnClose" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UseFormerTextWrapping" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ChartAutoUpdate" config:type="boolean">true</config:config-item>
   <config:config-item config:name="AddParaTableSpacingAtStart" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintTables" config:type="boolean">true</config:config-item>
   <config:config-item config:name="AllowPrintJobCancel" config:type="boolean">true</config:config-item>
   <config:config-item config:name="AddParaTableSpacing" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintDrawings" config:type="boolean">true</config:config-item>
   <config:config-item config:name="AddParaSpacingToTableCells" config:type="boolean">true</config:config-item>
   <config:config-item config:name="UseFormerLineSpacing" config:type="boolean">false</config:config-item>
   <config:config-item config:name="OutlineLevelYieldsNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="LinkUpdateMode" config:type="short">1</config:config-item>
   <config:config-item config:name="DoNotResetParaAttrsForNumFont" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ApplyUserData" config:type="boolean">false</config:config-item>
   <config:config-item config:name="StylesNoDefault" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbeddedDatabaseName" config:type="string"/>
   <config:config-item config:name="FloattableNomargins" config:type="boolean">false</config:config-item>
   <config:config-item config:name="BackgroundParaOverDrawings" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintBlackFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrinterName" config:type="string"/>
   <config:config-item config:name="UseFormerObjectPositioning" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TabOverMargin" config:type="boolean">false</config:config-item>
   <config:config-item config:name="SaveGlobalDocumentLinks" config:type="boolean">false</config:config-item>
   <config:config-item config:name="CurrentDatabaseDataSource" config:type="string"/>
   <config:config-item config:name="IsKernAsianPunctuation" config:type="boolean">false</config:config-item>
   <config:config-item config:name="CharacterCompressionType" config:type="short">0</config:config-item>
   <config:config-item config:name="SmallCapsPercentage66" config:type="boolean">false</config:config-item>
   <config:config-item config:name="CurrentDatabaseCommand" config:type="string"/>
   <config:config-item config:name="CurrentDatabaseCommandType" config:type="int">0</config:config-item>
   <config:config-item config:name="FieldAutoUpdate" config:type="boolean">true</config:config-item>
   <config:config-item config:name="IgnoreTabsAndBlanksForLineCalculation" config:type="boolean">false</config:config-item>
   <config:config-item config:name="LoadReadonly" config:type="boolean">false</config:config-item>
   <config:config-item config:name="DoNotCaptureDrawObjsOnPage" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ClipAsCharacterAnchoredWriterFlyFrames" config:type="boolean">false</config:config-item>
   <config:config-item config:name="SurroundTextWrapSmall" config:type="boolean">false</config:config-item>
   <config:config-item config:name="UnxForceZeroExtLeading" config:type="boolean">false</config:config-item>
   <config:config-item config:name="TabAtLeftIndentForParagraphsInList" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintRightPages" config:type="boolean">true</config:config-item>
   <config:config-item config:name="Rsid" config:type="int">2616813</config:config-item>
   <config:config-item config:name="MathBaselineAlignment" config:type="boolean">true</config:config-item>
   <config:config-item config:name="MsWordCompTrailingBlanks" config:type="boolean">false</config:config-item>
   <config:config-item config:name="InvertBorderSpacing" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbedFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrinterIndependentLayout" config:type="string">high-resolution</config:config-item>
   <config:config-item config:name="TabOverflow" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintGraphics" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PropLineSpacingShrinksFirstLine" config:type="boolean">true</config:config-item>
   <config:config-item config:name="UnbreakableNumberings" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AddFrameOffsets" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ClippedPictures" config:type="boolean">false</config:config-item>
   <config:config-item config:name="EmbedSystemFonts" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ApplyParagraphMarkFormatToNumbering" config:type="boolean">false</config:config-item>
   <config:config-item config:name="SubtractFlysAnchoredAtFlys" config:type="boolean">false</config:config-item>
   <config:config-item config:name="AddVerticalFrameOffsets" config:type="boolean">false</config:config-item>
   <config:config-item config:name="ProtectForm" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintEmptyPages" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintControls" config:type="boolean">true</config:config-item>
   <config:config-item config:name="PrintHiddenText" config:type="boolean">false</config:config-item>
   <config:config-item config:name="PrintAnnotationMode" config:type="short">0</config:config-item>
   <config:config-item config:name="PrintPageBackground" config:type="boolean">true</config:config-item>
  </config:config-item-set>
 </office:settings>
 <office:scripts>
  <office:script script:language="ooo:Basic">
   <ooo:libraries xmlns:ooo="http://openoffice.org/2004/office" xmlns:xlink="http://www.w3.org/1999/xlink">
    <ooo:library-embedded ooo:name="Standard"/>
   </ooo:libraries>
  </office:script>
 </office:scripts>
 <office:font-face-decls>
  <style:font-face style:name="Lohit Devanagari1" svg:font-family="&apos;Lohit Devanagari&apos;"/>
  <style:font-face style:name="DejaVu Sans Mono" svg:font-family="&apos;DejaVu Sans Mono&apos;" style:font-family-generic="modern" style:font-pitch="fixed"/>
  <style:font-face style:name="Liberation Mono1" svg:font-family="&apos;Liberation Mono&apos;" style:font-family-generic="modern" style:font-pitch="fixed"/>
  <style:font-face style:name="Liberation Mono" svg:font-family="&apos;Liberation Mono&apos;" style:font-adornments="Regular" style:font-family-generic="modern" style:font-pitch="fixed"/>
  <style:font-face style:name="Liberation Serif" svg:font-family="&apos;Liberation Serif&apos;" style:font-family-generic="roman" style:font-pitch="variable"/>
  <style:font-face style:name="Liberation Sans" svg:font-family="&apos;Liberation Sans&apos;" style:font-family-generic="swiss" style:font-pitch="variable"/>
  <style:font-face style:name="Lohit Devanagari" svg:font-family="&apos;Lohit Devanagari&apos;" style:font-family-generic="system" style:font-pitch="variable"/>
  <style:font-face style:name="Noto Sans CJK SC Regular" svg:font-family="&apos;Noto Sans CJK SC Regular&apos;" style:font-family-generic="system" style:font-pitch="variable"/>
 </office:font-face-decls>
 <office:styles>
  <style:default-style style:family="graphic">
   <style:graphic-properties svg:stroke-color="#3465a4" draw:fill-color="#729fcf" fo:wrap-option="no-wrap" draw:shadow-offset-x="0.3cm" draw:shadow-offset-y="0.3cm" draw:start-line-spacing-horizontal="0.283cm" draw:start-line-spacing-vertical="0.283cm" draw:end-line-spacing-horizontal="0.283cm" draw:end-line-spacing-vertical="0.283cm" style:flow-with-text="false"/>
   <style:paragraph-properties style:text-autospace="ideograph-alpha" style:line-break="strict" style:font-independent-line-spacing="false">
    <style:tab-stops/>
   </style:paragraph-properties>
   <style:text-properties style:use-window-font-color="true" style:font-name="Liberation Serif" fo:font-size="12pt" fo:language="en" fo:country="US" style:letter-kerning="true" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zh" style:country-asian="CN" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="hi" style:country-complex="IN"/>
  </style:default-style>
  <style:default-style style:family="paragraph">
   <style:paragraph-properties fo:hyphenation-ladder-count="no-limit" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:tab-stop-distance="1.251cm" style:writing-mode="page"/>
   <style:text-properties style:use-window-font-color="true" style:font-name="Liberation Serif" fo:font-size="12pt" fo:language="en" fo:country="US" style:letter-kerning="true" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zh" style:country-asian="CN" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="hi" style:country-complex="IN" fo:hyphenate="false" fo:hyphenation-remain-char-count="2" fo:hyphenation-push-char-count="2"/>
  </style:default-style>
  <style:default-style style:family="table">
   <style:table-properties table:border-model="collapsing"/>
  </style:default-style>
  <style:default-style style:family="table-row">
   <style:table-row-properties fo:keep-together="auto"/>
  </style:default-style>
  <style:style style:name="Standard" style:family="paragraph" style:class="text"/>
  <style:style style:name="Heading" style:family="paragraph" style:parent-style-name="Standard" style:next-style-name="Text_20_body" style:class="text">
   <style:paragraph-properties fo:margin-top="0.423cm" fo:margin-bottom="0.212cm" loext:contextual-spacing="false" fo:keep-with-next="always"/>
   <style:text-properties style:font-name="Liberation Sans" fo:font-family="&apos;Liberation Sans&apos;" style:font-family-generic="swiss" style:font-pitch="variable" fo:font-size="14pt" style:font-name-asian="Noto Sans CJK SC Regular" style:font-family-asian="&apos;Noto Sans CJK SC Regular&apos;" style:font-family-generic-asian="system" style:font-pitch-asian="variable" style:font-size-asian="14pt" style:font-name-complex="Lohit Devanagari" style:font-family-complex="&apos;Lohit Devanagari&apos;" style:font-family-generic-complex="system" style:font-pitch-complex="variable" style:font-size-complex="14pt"/>
  </style:style>
  <style:style style:name="Text_20_body" style:display-name="Text body" style:family="paragraph" style:parent-style-name="Standard" style:class="text">
   <style:paragraph-properties fo:margin-top="0cm" fo:margin-bottom="0.247cm" loext:contextual-spacing="false" fo:line-height="120%"/>
  </style:style>
  <style:style style:name="List" style:family="paragraph" style:parent-style-name="Text_20_body" style:class="list">
   <style:text-properties style:font-size-asian="12pt" style:font-name-complex="Lohit Devanagari1" style:font-family-complex="&apos;Lohit Devanagari&apos;"/>
  </style:style>
  <style:style style:name="Caption" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
   <style:paragraph-properties fo:margin-top="0.212cm" fo:margin-bottom="0.212cm" loext:contextual-spacing="false" text:number-lines="false" text:line-number="0"/>
   <style:text-properties fo:font-size="12pt" fo:font-style="italic" style:font-size-asian="12pt" style:font-style-asian="italic" style:font-name-complex="Lohit Devanagari1" style:font-family-complex="&apos;Lohit Devanagari&apos;" style:font-size-complex="12pt" style:font-style-complex="italic"/>
  </style:style>
  <style:style style:name="Index" style:family="paragraph" style:parent-style-name="Standard" style:class="index">
   <style:paragraph-properties text:number-lines="false" text:line-number="0"/>
   <style:text-properties style:font-size-asian="12pt" style:font-name-complex="Lohit Devanagari1" style:font-family-complex="&apos;Lohit Devanagari&apos;"/>
  </style:style>
  <style:style style:name="Preformatted_20_Text" style:display-name="Preformatted Text" style:family="paragraph" style:parent-style-name="Standard" style:class="html">
   <style:paragraph-properties fo:margin-top="0cm" fo:margin-bottom="0cm" loext:contextual-spacing="false" style:writing-mode="page"/>
   <style:text-properties style:font-name="Liberation Mono" fo:font-family="&apos;Liberation Mono&apos;" style:font-style-name="Regular" style:font-family-generic="modern" style:font-pitch="fixed" fo:font-size="10pt" style:font-name-asian="DejaVu Sans Mono" style:font-family-asian="&apos;DejaVu Sans Mono&apos;" style:font-family-generic-asian="modern" style:font-pitch-asian="fixed" style:font-size-asian="10pt" style:font-name-complex="Liberation Mono1" style:font-family-complex="&apos;Liberation Mono&apos;" style:font-family-generic-complex="modern" style:font-pitch-complex="fixed" style:font-size-complex="10pt"/>
  </style:style>
  <style:style style:name="Footer" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
   <style:paragraph-properties text:number-lines="false" text:line-number="0">
    <style:tab-stops>
     <style:tab-stop style:position="8.5cm" style:type="center"/>
     <style:tab-stop style:position="17cm" style:type="right"/>
    </style:tab-stops>
   </style:paragraph-properties>
  </style:style>
  <style:style style:name="Header" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
   <style:paragraph-properties text:number-lines="false" text:line-number="0">
    <style:tab-stops>
     <style:tab-stop style:position="8.5cm" style:type="center"/>
     <style:tab-stop style:position="17cm" style:type="right"/>
    </style:tab-stops>
   </style:paragraph-properties>
  </style:style>
  <style:style style:name="Source_20_Text" style:display-name="Source Text" style:family="text">
   <style:text-properties style:font-name="Liberation Mono1" fo:font-family="&apos;Liberation Mono&apos;" style:font-family-generic="modern" style:font-pitch="fixed" style:font-name-asian="DejaVu Sans Mono" style:font-family-asian="&apos;DejaVu Sans Mono&apos;" style:font-family-generic-asian="modern" style:font-pitch-asian="fixed" style:font-name-complex="Liberation Mono1" style:font-family-complex="&apos;Liberation Mono&apos;" style:font-family-generic-complex="modern" style:font-pitch-complex="fixed"/>
  </style:style>
  <style:style style:name="Line_20_numbering" style:display-name="Line numbering" style:family="text"/>
  <style:style style:name="Numbering_20_Symbols" style:display-name="Numbering Symbols" style:family="text"/>
  <style:style style:name="Internet_20_link" style:display-name="Internet link" style:family="text">
   <style:text-properties fo:color="#000080" fo:language="zxx" fo:country="none" style:text-underline-style="solid" style:text-underline-width="auto" style:text-underline-color="font-color" style:language-asian="zxx" style:country-asian="none" style:language-complex="zxx" style:country-complex="none"/>
  </style:style>
  <style:style style:name="Frame" style:family="graphic">
   <style:graphic-properties text:anchor-type="paragraph" svg:x="0cm" svg:y="0cm" fo:margin-left="0.201cm" fo:margin-right="0.201cm" fo:margin-top="0.201cm" fo:margin-bottom="0.201cm" style:wrap="parallel" style:number-wrapped-paragraphs="no-limit" style:wrap-contour="false" style:vertical-pos="top" style:vertical-rel="paragraph-content" style:horizontal-pos="center" style:horizontal-rel="paragraph-content" fo:padding="0.15cm" fo:border="0.06pt solid #000000"/>
  </style:style>
  <text:outline-style style:name="Outline">
   <text:outline-level-style text:level="1" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="2" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="3" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="4" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="5" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="6" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="7" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="8" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="9" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
   <text:outline-level-style text:level="10" style:num-format="">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab"/>
    </style:list-level-properties>
   </text:outline-level-style>
  </text:outline-style>
  <text:list-style style:name="Numbering_20_2" style:display-name="Numbering 2">
   <text:list-level-style-number text:level="1" text:style-name="Numbering_20_Symbols" style:num-format="1">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment" fo:text-align="end">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.499cm" fo:text-indent="-0.499cm" fo:margin-left="0.499cm"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="2" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="2">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="0.998cm" fo:text-indent="-0.499cm" fo:margin-left="0.998cm"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="3" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="3">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="1.998cm" fo:text-indent="-1cm" fo:margin-left="1.998cm"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="4" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="4">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="3.249cm" fo:text-indent="-1.251cm" fo:margin-left="3.249cm"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="5" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="5">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="4.748cm" fo:text-indent="-1.499cm" fo:margin-left="4.748cm"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="6" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="6">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="6.549cm" fo:text-indent="-1.801cm" fo:margin-left="6.549cm"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="7" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="7">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="8.849cm" fo:text-indent="-2.3cm" fo:margin-left="8.849cm"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="8" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="8">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="11.449cm" fo:text-indent="-2.6cm" fo:margin-left="11.449cm"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="9" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="9">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="14.25cm" fo:text-indent="-2.801cm" fo:margin-left="14.25cm"/>
    </style:list-level-properties>
   </text:list-level-style-number>
   <text:list-level-style-number text:level="10" text:style-name="Numbering_20_Symbols" style:num-format="1" text:start-value="10">
    <style:list-level-properties text:list-level-position-and-space-mode="label-alignment">
     <style:list-level-label-alignment text:label-followed-by="listtab" text:list-tab-stop-position="17.351cm" fo:text-indent="-3.101cm" fo:margin-left="17.351cm"/>
    </style:list-level-properties>
   </text:list-level-style-number>
  </text:list-style>
  <text:notes-configuration text:note-class="footnote" style:num-format="1" text:start-value="0" text:footnotes-position="page" text:start-numbering-at="document"/>
  <text:notes-configuration text:note-class="endnote" style:num-format="i" text:start-value="0"/>
  <text:linenumbering-configuration text:style-name="Line_20_numbering" text:number-lines="false" text:offset="0.499cm" style:num-format="1" text:number-position="left" text:increment="1"/>
 </office:styles>
 <office:automatic-styles>
  <style:style style:name="P1" style:family="paragraph" style:parent-style-name="Preformatted_20_Text">
   <style:text-properties fo:language="zxx" fo:country="none" style:language-asian="zxx" style:country-asian="none" style:language-complex="zxx" style:country-complex="none"/>
  </style:style>
  <style:style style:name="P2" style:family="paragraph" style:parent-style-name="Preformatted_20_Text">
   <style:text-properties fo:language="zxx" fo:country="none" officeooo:paragraph-rsid="001f3ffe" style:language-asian="zxx" style:country-asian="none" style:language-complex="zxx" style:country-complex="none"/>
  </style:style>
  <style:style style:name="P3" style:family="paragraph" style:parent-style-name="Standard">
   <style:paragraph-properties fo:margin-left="0cm" fo:margin-right="0cm" fo:margin-top="0cm" fo:margin-bottom="0cm" loext:contextual-spacing="false" fo:line-height="100%" fo:text-align="start" style:justify-single-word="false" fo:hyphenation-ladder-count="no-limit" fo:text-indent="0cm" style:auto-text-indent="false" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:writing-mode="lr-tb">
    <style:tab-stops/>
   </style:paragraph-properties>
   <style:text-properties fo:hyphenate="false" fo:hyphenation-remain-char-count="2" fo:hyphenation-push-char-count="2"/>
  </style:style>
  <style:style style:name="P4" style:family="paragraph" style:parent-style-name="Preformatted_20_Text" style:list-style-name="Numbering_20_2">
   <style:text-properties fo:language="zxx" fo:country="none" style:language-asian="zxx" style:country-asian="none" style:language-complex="zxx" style:country-complex="none"/>
  </style:style>
  <style:style style:name="P5" style:family="paragraph" style:parent-style-name="Preformatted_20_Text" style:list-style-name="Numbering_20_2">
   <style:text-properties fo:language="zxx" fo:country="none" officeooo:paragraph-rsid="001f3ffe" style:language-asian="zxx" style:country-asian="none" style:language-complex="zxx" style:country-complex="none"/>
  </style:style>
  <style:style style:name="P6" style:family="paragraph">
   <style:paragraph-properties fo:margin-left="0cm" fo:margin-right="0cm" fo:margin-top="0cm" fo:margin-bottom="0cm" fo:line-height="100%" fo:text-align="start" fo:text-indent="0cm" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:writing-mode="lr-tb">
    <style:tab-stops/>
   </style:paragraph-properties>
   <style:text-properties fo:hyphenate="false"/>
  </style:style>
  <style:style style:name="P7" style:family="paragraph">
   <style:paragraph-properties fo:margin-left="0cm" fo:margin-right="0cm" fo:margin-top="0cm" fo:margin-bottom="0cm" fo:line-height="100%" fo:text-align="start" fo:text-indent="0cm" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:writing-mode="lr-tb">
    <style:tab-stops/>
   </style:paragraph-properties>
   <style:text-properties fo:hyphenate="false"/>
  </style:style>
  <style:style style:name="P8" style:family="paragraph">
   <style:paragraph-properties fo:margin-left="0cm" fo:margin-right="0cm" fo:margin-top="0cm" fo:margin-bottom="0cm" fo:line-height="100%" fo:text-align="start" fo:text-indent="0cm" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:writing-mode="lr-tb">
    <style:tab-stops/>
   </style:paragraph-properties>
   <style:text-properties fo:hyphenate="false"/>
  </style:style>
  <style:style style:name="T1" style:family="text">
   <style:text-properties officeooo:rsid="00217ee6"/>
  </style:style>
  <style:style style:name="T2" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" style:use-window-font-color="true" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="normal" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" loext:char-shading-value="0" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zh" style:country-asian="CN" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="hi" style:country-complex="IN" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T3" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" style:use-window-font-color="true" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="normal" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zh" style:country-asian="CN" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="hi" style:country-complex="IN" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T4" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" style:use-window-font-color="true" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="normal" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zh" style:country-asian="CN" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="hi" style:country-complex="IN" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T5" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" fo:color="#000000" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="normal" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zh" style:country-asian="CN" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="hi" style:country-complex="IN" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T6" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" fo:color="#000000" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="normal" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zh" style:country-asian="CN" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="hi" style:country-complex="IN" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:style style:name="T7" style:family="text">
   <style:text-properties fo:font-variant="normal" fo:text-transform="none" style:use-window-font-color="true" style:text-outline="false" style:text-line-through-style="none" style:text-line-through-type="none" style:text-position="0% 100%" style:font-name="Liberation Serif" fo:font-size="10pt" fo:letter-spacing="normal" fo:language="zxx" fo:country="none" fo:font-style="normal" fo:text-shadow="none" style:text-underline-style="none" fo:font-weight="bold" style:text-underline-mode="continuous" style:text-overline-mode="continuous" style:text-line-through-mode="continuous" style:letter-kerning="true" fo:background-color="transparent" style:font-name-asian="Noto Sans CJK SC Regular" style:font-size-asian="10.5pt" style:language-asian="zh" style:country-asian="CN" style:font-style-asian="normal" style:font-weight-asian="normal" style:font-name-complex="Lohit Devanagari" style:font-size-complex="12pt" style:language-complex="hi" style:country-complex="IN" style:font-style-complex="normal" style:font-weight-complex="normal" style:text-emphasize="none" style:text-scale="100%" style:font-relief="none" style:text-overline-style="none" style:text-overline-color="font-color"/>
  </style:style>
  <style:page-layout style:name="pm1">
   <style:page-layout-properties fo:page-width="21.001cm" fo:page-height="29.7cm" style:num-format="1" style:print-orientation="portrait" fo:margin-top="1.3cm" fo:margin-bottom="1.3cm" fo:margin-left="1.499cm" fo:margin-right="1.499cm" style:writing-mode="lr-tb" style:footnote-max-height="0cm">
    <style:footnote-sep style:width="0.018cm" style:distance-before-sep="0.101cm" style:distance-after-sep="0.101cm" style:line-style="solid" style:adjustment="left" style:rel-width="25%" style:color="#000000"/>
   </style:page-layout-properties>
   <style:header-style>
    <style:header-footer-properties fo:min-height="0.6cm" fo:margin-left="0cm" fo:margin-right="0cm" fo:margin-bottom="0.499cm" fo:background-color="transparent" style:dynamic-spacing="false" draw:fill="none" draw:fill-color="#729fcf"/>
   </style:header-style>
   <style:footer-style/>
  </style:page-layout>
 </office:automatic-styles>
 <office:master-styles>
  <style:master-page style:name="Standard" style:page-layout-name="pm1">
   <style:header>
    <text:p text:style-name="Header"><text:page-number text:select-page="current">1</text:page-number></text:p>
   </style:header>
  </style:master-page>
 </office:master-styles>
 <office:body>
  <office:text text:use-soft-page-breaks="true">
   <office:forms form:automatic-focus="false" form:apply-design-mode="false"/>
   <text:sequence-decls>
    <text:sequence-decl text:display-outline-level="0" text:name="Illustration"/>
    <text:sequence-decl text:display-outline-level="0" text:name="Table"/>
    <text:sequence-decl text:display-outline-level="0" text:name="Text"/>
    <text:sequence-decl text:display-outline-level="0" text:name="Drawing"/>
   </text:sequence-decls>
   <text:list xml:id="list1247628255" text:style-name="Numbering_20_2">
    <text:list-item>
     <text:p text:style-name="P4">/* ***** BEGIN LICENSE BLOCK *****</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Version: MPL 1.1/GPL 2.0/LGPL 2.1</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Copyright (C) 2002-2017 Németh László</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* The contents of this file are subject to the Mozilla Public License Version</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* the License. You may obtain a copy of the License at</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* http://www.mozilla.org/MPL/</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* for the specific language governing rights and limitations under the</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* License.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Alternatively, the contents of this file may be used under the terms of</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* in which case the provisions of the GPL or the LGPL are applicable instead</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* of those above. If you wish to allow use of your version of this file only</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* under the terms of either the GPL or the LGPL, and not to allow others to</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* use your version of this file under the terms of the MPL, indicate your</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* decision by deleting the provisions above and replace them with the notice</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* and other provisions required by the GPL or the LGPL. If you do not delete</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* the provisions above, a recipient may use your version of this file under</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* the terms of any one of the MPL, the GPL or the LGPL.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* ***** END LICENSE BLOCK ***** */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">/*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* And Contributors. <text:s/>All rights reserved.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* Redistribution and use in source and binary forms, with or without</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* modification, are permitted provided that the following conditions</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* are met:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* 1. Redistributions of source code must retain the above copyright</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>notice, this list of conditions and the following disclaimer.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* 2. Redistributions in binary form must reproduce the above copyright</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>notice, this list of conditions and the following disclaimer in the</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>documentation and/or other materials provided with the distribution.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* 3. All modifications to the source code must be clearly marked as</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>such. <text:s/>Binary redistributions based on modified source code</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>must be clearly marked as modified versions in the documentation</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* <text:s text:c="3"/>and/or other materials provided with the distribution.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* ``AS IS&apos;&apos; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. <text:s/>IN NO EVENT SHALL</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s/>* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* SUCH DAMAGE.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*/</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &lt;stdlib.h&gt;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &lt;string.h&gt;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &lt;stdio.h&gt;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &quot;affixmgr.hxx&quot;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &quot;hunspell.hxx&quot;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &quot;suggestmgr.hxx&quot;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &quot;hunspell.h&quot;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &quot;csutil.hxx&quot;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &lt;limits&gt;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#include &lt;string&gt;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#define MAXWORDUTF8LEN (MAXWORDLEN * 3)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">class HunspellImpl</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">{</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">public:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>HunspellImpl(const char* affpath, const char* dpath, const char* key = NULL);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>~HunspellImpl();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int add_dic(const char* dpath, const char* key = NULL);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; suffix_suggest(const std::string&amp; root_word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; generate(const std::string&amp; word, const std::vector&lt;std::string&gt;&amp; pl);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; generate(const std::string&amp; word, const std::string&amp; pattern);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; stem(const std::string&amp; word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; stem(const std::vector&lt;std::string&gt;&amp; morph);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; analyze(const std::string&amp; word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int get_langnum() const;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>bool input_conv(const std::string&amp; word, std::string&amp; dest);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>bool spell(const std::string&amp; word, int* info = NULL, std::string* root = NULL);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; suggest(const std::string&amp; word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const std::string&amp; get_wordchars_cpp() const;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const std::vector&lt;w_char&gt;&amp; get_wordchars_utf16() const;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const std::string&amp; get_dict_encoding() const;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int add(const std::string&amp; word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int add_with_affix(const std::string&amp; word, const std::string&amp; example);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int remove(const std::string&amp; word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const std::string&amp; get_version_cpp() const;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>struct cs_info* get_csconv();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int spell(const char* word, int* info = NULL, char** root = NULL);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int suggest(char*** slst, const char* word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int suffix_suggest(char*** slst, const char* root_word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>void free_list(char*** slst, int n);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>char* get_dic_encoding();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int analyze(char*** slst, const char* word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int stem(char*** slst, const char* word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int stem(char*** slst, char** morph, int n);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int generate(char*** slst, const char* word, const char* word2);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int generate(char*** slst, const char* word, char** desc, int n);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* get_wordchars() const;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* get_version() const;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int input_conv(const char* word, char* dest, size_t destsize);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">private:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>AffixMgr* pAMgr;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;HashMgr*&gt; m_HMgrs;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>SuggestMgr* pSMgr;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>char* affixpath;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string encoding;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>struct cs_info* csconv;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int langnum;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int utf8;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int complexprefixes;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; wordbreak;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">private:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>void cleanword(std::string&amp; dest, const std::string&amp;, int* pcaptype, int* pabbrev);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t cleanword2(std::string&amp; dest,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="20"/>std::vector&lt;w_char&gt;&amp; dest_u,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="20"/>const std::string&amp; src,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="20"/>int* pcaptype,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="20"/>size_t* pabbrev);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>void mkinitcap(std::string&amp; u8);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int mkinitcap2(std::string&amp; u8, std::vector&lt;w_char&gt;&amp; u16);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int mkinitsmall2(std::string&amp; u8, std::vector&lt;w_char&gt;&amp; u16);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>void mkallcap(std::string&amp; u8);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int mkallsmall2(std::string&amp; u8, std::vector&lt;w_char&gt;&amp; u16);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>struct hentry* checkword(const std::string&amp; source, int* info, std::string* root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string sharps_u8_l1(const std::string&amp; source);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>hentry*</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>spellsharps(std::string&amp; base, size_t start_pos, int, int, int* info, std::string* root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int is_keepcase(const hentry* rv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>void insert_sug(std::vector&lt;std::string&gt;&amp; slst, const std::string&amp; word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>void cat_result(std::string&amp; result, const std::string&amp; st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; spellml(const std::string&amp; word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string get_xml_par(const char* par);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* get_xml_pos(const char* s, const char* attr);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; get_xml_list(const char* list, const char* tag);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int check_xml_par(const char* q, const char* attr, const char* value);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">private:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>HunspellImpl(const HunspellImpl&amp;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>HunspellImpl&amp; operator=(const HunspellImpl&amp;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">};</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">HunspellImpl::HunspellImpl(const char* affpath, const char* dpath, const char* key) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>csconv = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>utf8 = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>complexprefixes = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>affixpath = mystrdup(affpath);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>/* first set up the hash manager */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>m_HMgrs.push_back(new HashMgr(dpath, affpath, key));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>/* next set up the affix manager */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>/* it needs access to the hash manager lookup methods */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>pAMgr = new AffixMgr(affpath, m_HMgrs, key);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>/* get the preferred try string and the dictionary */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>/* encoding from the Affix Manager for that dictionary */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>char* try_string = pAMgr-&gt;get_try_string();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>encoding = pAMgr-&gt;get_encoding();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>langnum = pAMgr-&gt;get_langnum();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>utf8 = pAMgr-&gt;get_utf8();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!utf8)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>csconv = get_current_cs(encoding);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>complexprefixes = pAMgr-&gt;get_complexprefixes();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>wordbreak = pAMgr-&gt;get_breaktable();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>/* and finally set up the suggestion manager */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>pSMgr = new SuggestMgr(try_string, MAXSUGGESTION, pAMgr);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (try_string)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>free(try_string);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">HunspellImpl::~HunspellImpl() {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>delete pSMgr;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>delete pAMgr;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (size_t i = 0; i &lt; m_HMgrs.size(); ++i)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>delete m_HMgrs[i];</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>pSMgr = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>pAMgr = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#ifdef MOZILLA_CLIENT</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>delete[] csconv;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#endif</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>csconv = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (affixpath)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>free(affixpath);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>affixpath = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// load extra dictionaries</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::add_dic(const char* dpath, const char* key) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!affixpath)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>m_HMgrs.push_back(new HashMgr(dpath, affixpath, key));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// make a copy of src at destination while removing all leading</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// blanks and removing any trailing periods after recording</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// their presence with the abbreviation flag</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// also since already going through character by character,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// set the capitalization type</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// return the length of the &quot;cleaned&quot; (and UTF-8 encoded) word</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">size_t HunspellImpl::cleanword2(std::string&amp; dest,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="25"/>std::vector&lt;w_char&gt;&amp; dest_utf,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="25"/>const std::string&amp; src,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="25"/>int* pcaptype,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="25"/>size_t* pabbrev) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>dest.clear();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>dest_utf.clear();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* q = src.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// first skip over any leading blanks</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>while (*q == &apos; &apos;)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>++q;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// now strip off any trailing periods (recording their presence)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>*pabbrev = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int nl = strlen(q);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>while ((nl &gt; 0) &amp;&amp; (*(q + nl - 1) == &apos;.&apos;)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>nl--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>(*pabbrev)++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// if no characters are left it can&apos;t be capitalized</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (nl &lt;= 0) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*pcaptype = NOCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>dest.append(q, nl);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>nl = dest.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>u8_u16(dest_utf, dest);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*pcaptype = get_captype_utf8(dest_utf, langnum);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*pcaptype = get_captype(dest, csconv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return nl;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">void HunspellImpl::cleanword(std::string&amp; dest,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="24"/>const std::string&amp; src,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="24"/>int* pcaptype,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="24"/>int* pabbrev) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>dest.clear();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const unsigned char* q = (const unsigned char*)src.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int firstcap = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// first skip over any leading blanks</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><office:annotation office:name="__Annotation__4252_3349485815">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-15T22:38:51.328686952</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P6"><text:span text:style-name="T3">Trim leading space</text:span></text:p>
      </office:annotation><text:s text:c="2"/>while (*q == &apos; &apos;)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>++q;<office:annotation-end office:name="__Annotation__4252_3349485815"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// now strip off any trailing periods (recording their presence)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>*pabbrev = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int nl = strlen((const char*)q);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><office:annotation office:name="__Annotation__4253_3349485815">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-15T22:39:27.974666530</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P6"><text:span text:style-name="T3">Trim trailing periods</text:span></text:p>
      </office:annotation><text:s text:c="2"/>while ((nl &gt; 0) &amp;&amp; (*(q + nl - 1) == &apos;.&apos;)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>nl--;<office:annotation-end office:name="__Annotation__4253_3349485815"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><office:annotation office:name="__Annotation__4254_3349485815">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-15T22:39:39.647601789</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P6"><text:span text:style-name="T3">Count trailing periods</text:span></text:p>
      </office:annotation><text:s text:c="4"/>(*pabbrev)++;<office:annotation-end office:name="__Annotation__4254_3349485815"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// if no characters are left it can&apos;t be capitalized</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (nl &lt;= 0) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*pcaptype = NOCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// now determine the capitalization type of the first nl letters</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int ncap = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int nneutral = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int nc = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>while (nl &gt; 0) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>nc++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (<office:annotation office:name="__Annotation__4259_1826620842">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-16T20:58:08.307676963</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P6"><text:span text:style-name="T3">isupper(*q)</text:span></text:p>
      </office:annotation>csconv[(*q)].ccase<office:annotation-end office:name="__Annotation__4259_1826620842"/>)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>ncap++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (csconv[(*q)].cupper == csconv[(*q)].clower)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>nneutral++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>dest.push_back(*q++);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>nl--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// remember to terminate the destination string</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>firstcap = csconv[static_cast&lt;unsigned char&gt;(dest[0])].ccase;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::vector&lt;w_char&gt; t;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>u8_u16(t, src);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t i = 0; i &lt; t.size(); ++i) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>unsigned short idx = (t[i].h &lt;&lt; 8) + t[i].l;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>unsigned short low = unicodetolower(idx, langnum);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (idx != low)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>ncap++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (unicodetoupper(idx, langnum) == low)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>nneutral++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>u16_u8(dest, t);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (ncap) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>unsigned short idx = (t[0].h &lt;&lt; 8) + t[0].l;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>firstcap = (idx != unicodetolower(idx, langnum));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// now finally set the captype</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (ncap == 0) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*pcaptype = NOCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else if ((ncap == 1) &amp;&amp; firstcap) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*pcaptype = INITCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else if ((ncap == nc) || ((ncap + nneutral) == nc)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*pcaptype = ALLCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else if ((ncap &gt; 1) &amp;&amp; firstcap) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*pcaptype = HUHINITCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*pcaptype = HUHCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">void HunspellImpl::mkallcap(std::string&amp; u8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::vector&lt;w_char&gt; u16;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>u8_u16(u16, u8);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>::mkallcap_utf(u16, langnum);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>u16_u8(u8, u16);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>::mkallcap(u8, csconv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::mkallsmall2(std::string&amp; u8, std::vector&lt;w_char&gt;&amp; u16) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>::mkallsmall_utf(u16, langnum);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>u16_u8(u8, u16);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>::mkallsmall(u8, csconv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return u8.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// convert UTF-8 sharp S codes to latin 1</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::string HunspellImpl::sharps_u8_l1(const std::string&amp; source) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string dest(source);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>mystrrep(dest, &quot;\xC3\x9F&quot;, &quot;\xDF&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return dest;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// recursive search for right ss - sharp s <office:annotation office:name="__Annotation__4475_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:44:36.519667208</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Actually </text:span><text:span text:style-name="T4"><text:a xlink:href="https://en.wikipedia.org/wiki/Permutation#Permutations_with_repetition" xlink:type="simple">permutations with repetitions</text:a></text:span></text:p>
      </office:annotation>permutations<office:annotation-end office:name="__Annotation__4475_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">hentry* HunspellImpl::<office:annotation office:name="__Annotation__4476_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:45:29.527199702</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Receives a word in all lowercase with double ss. Tries to generate all permutations with repetitions by replacing the double s with sharp s and calls checkword().</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T4">E.g.:</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Input ss abc ss abc ss</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Generate:</text:span></text:p>
       <text:p text:style-name="P8"><text:span text:style-name="T5">ß abc ß abc ß</text:span></text:p>
       <text:p text:style-name="P8"><text:span text:style-name="T5">ß abc ß abc ss</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T4">ß abc ss abc ss</text:span></text:p>
       <text:p text:style-name="P8"><text:span text:style-name="T5">ss abc ß abc ß</text:span></text:p>
       <text:p text:style-name="P8"><text:span text:style-name="T5">...</text:span></text:p>
       <text:p text:style-name="P8"><text:span text:style-name="T5"/></text:p>
      </office:annotation>spellsharps<office:annotation-end office:name="__Annotation__4476_1161223734"/>(std::string&amp; base,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="30"/>size_t n_pos,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="30"/>int n,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="30"/>int repnum,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="30"/>int* info,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="30"/>std::string* root) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t pos = base.find(&quot;ss&quot;, n_pos);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (pos != std::string::npos &amp;&amp; (n &lt; MAXSHARPS)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>base[pos] = &apos;\xC3&apos;;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>base[pos + 1] = &apos;\x9F&apos;;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>hentry* h = spellsharps(base, pos + 2, n + 1, repnum + 1, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (h)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return h;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>base[pos] = &apos;s&apos;;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>base[pos + 1] = &apos;s&apos;;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>h = spellsharps(base, pos + 2, n + 1, repnum, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (h)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return h;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else if (repnum &gt; 0) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (utf8)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return checkword(base, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string tmp(sharps_u8_l1(base));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return checkword(tmp, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::is_keepcase(const hentry* rv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return pAMgr &amp;&amp; rv-&gt;astr &amp;&amp; pAMgr-&gt;get_keepcase() &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="9"/>TESTAFF(rv-&gt;astr, pAMgr-&gt;get_keepcase(), rv-&gt;alen);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">/* insert a word to the beginning of the suggestion array */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">void HunspellImpl::insert_sug(std::vector&lt;std::string&gt;&amp; slst, const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>slst.insert(slst.begin(), word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">bool HunspellImpl::<office:annotation office:name="__Annotation__4261_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:15:33.514746634</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">This is an entry point function, so it is a good place to start analyzing. The most important aspect of this functions are the calls to </text:span><text:span text:style-name="T7">checkword()</text:span><text:span text:style-name="T4"> and with what casing of the word it calls, everything else including info and root are of less importance.</text:span><text:span text:style-name="T4"> </text:span></text:p>
      </office:annotation>spell<office:annotation-end office:name="__Annotation__4261_1161223734"/>(const std::string&amp; word, int* <office:annotation office:name="__Annotation__4262_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:17:12.142323657</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">This is a bit (flag) set, out parametar here. It is also passed to checkword() as both in and out parameter. The values SPELL_ORIGCAP and SPELL_INITCAP are passed as IN to checkword and slightly modify its behavior.</text:span></text:p>
      </office:annotation>info<office:annotation-end office:name="__Annotation__4262_1161223734"/>, std::string* root) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>struct hentry* rv = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int info2 = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!info)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>info = &amp;info2;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*info = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// Hunspell supports XML input of the simplified API (see manual)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (word == SPELL_XML)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (word.size() &gt;= MAXWORDUTF8LEN)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (word.size() &gt;= MAXWORDLEN)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int captype = NOCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t abbv = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t wl = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string scw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;w_char&gt; sunicw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// input conversion</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/><office:annotation office:name="__Annotation__4268_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:21:26.450155972</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Substring replacements</text:span></text:p>
      </office:annotation>RepList* rl = pAMgr ? pAMgr-&gt;get_iconvtable() : NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>{</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string wspace;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>bool convstatus = rl ? rl-&gt;conv(word, wspace) : false;<office:annotation-end office:name="__Annotation__4268_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (convstatus)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/><office:annotation office:name="__Annotation__4269_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:22:01.162422193</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">1. Trim</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T4">2. Is abbreviation</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T4">3. classify casing</text:span></text:p>
      </office:annotation>wl = cleanword2(scw, sunicw, wspace, &amp;captype, &amp;abbv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>wl = cleanword2(scw, sunicw, word, &amp;captype, &amp;abbv);<office:annotation-end office:name="__Annotation__4269_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">#ifdef MOZILLA_CLIENT</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// accept the abbreviated words without dots</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// workaround for the incomplete tokenization of Mozilla</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>abbv = 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/>#endif</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (wl == 0 || m_HMgrs.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (root)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>root-&gt;clear();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><office:annotation office:name="__Annotation__4263_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:19:23.087071831</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Accept numbers. Can be extracted to a function or just use a regex &quot;\d([,.-]?\d)*&quot;.</text:span></text:p>
      </office:annotation><text:s text:c="2"/>// allow numbers with dots, dashes and commas (but forbid double separators:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// &quot;..&quot;, &quot;--&quot; etc.)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>enum { NBEGIN, NNUM, NSEP };</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int nstate = NBEGIN;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t i;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (i = 0; (i &lt; wl); i++) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if ((scw[i] &lt;= &apos;9&apos;) &amp;&amp; (scw[i] &gt;= &apos;0&apos;)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>nstate = NNUM;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else if ((scw[i] == &apos;,&apos;) || (scw[i] == &apos;.&apos;) || (scw[i] == &apos;-&apos;)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((nstate == NSEP) || (i == 0))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>nstate = NSEP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}<office:annotation-end office:name="__Annotation__4263_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if ((i == wl) &amp;&amp; (nstate == NNUM))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>switch (captype) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case HUHCAP:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>/* FALLTHROUGH */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case HUHINITCAP:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>*info += SPELL_ORIGCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>/* FALLTHROUGH */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case NOCAP:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>rv = <office:annotation office:name="__Annotation__4264_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:20:10.705870776</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Check abc</text:span></text:p>
      </office:annotation>checkword(scw, info, root)<office:annotation-end office:name="__Annotation__4264_1161223734"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((abbv) &amp;&amp; !(rv)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string u8buffer(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>rv = <office:annotation office:name="__Annotation__4265_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:20:22.697381077</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Check abc.</text:span></text:p>
      </office:annotation>checkword(u8buffer, info, root)<office:annotation-end office:name="__Annotation__4265_1161223734"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case ALLCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>*info += SPELL_ORIGCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>rv = <office:annotation office:name="__Annotation__4266_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:20:35.034173632</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Check ABC</text:span></text:p>
      </office:annotation>checkword(scw, info, root)<office:annotation-end office:name="__Annotation__4266_1161223734"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (rv)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (abbv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string u8buffer(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>rv = <office:annotation office:name="__Annotation__4267_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:20:45.127887294</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Check ABC.</text:span></text:p>
      </office:annotation>checkword(u8buffer, info, root)<office:annotation-end office:name="__Annotation__4267_1161223734"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (rv)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// Spec. prefix handling for Catalan, French, Italian:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// prefixes separated by apostrophe (SANT&apos;ELIA -&gt; Sant&apos;+Elia).</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>size_t apos = pAMgr ? scw.find(&apos;\&apos;&apos;) : std::string::npos;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (apos != std::string::npos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>mkallsmall2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>//conversion may result in string with different len to pre-mkallsmall2</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>//so re-scan</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (apos != std::string::npos &amp;&amp; apos &lt; scw.size() - 1) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>std::string part1 = scw.substr(0, apos+1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>std::string part2 = scw.substr(apos+1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>std::vector&lt;w_char&gt; part1u, part2u;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>u8_u16(part1u, part1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="12"/>u8_u16(part2u, part2);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>mkinitcap2(part2, part2u);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>scw = part1 + part2;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>sunicw = part1u;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>sunicw.insert(sunicw.end(), part2u.begin(), part2u.end());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>rv = <office:annotation office:name="__Annotation__4314_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:23:42.642818247</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Check abc’Xyz</text:span></text:p>
      </office:annotation>checkword(scw, info, root);<office:annotation-end office:name="__Annotation__4314_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (rv)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>mkinitcap2(part2, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>scw = part1 + part2;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>rv = <office:annotation office:name="__Annotation__4315_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:24:13.178997861</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Same as above</text:span></text:p>
      </office:annotation>checkword(scw, info, root)<office:annotation-end office:name="__Annotation__4315_1161223734"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (rv)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>mkinitcap2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>rv = <office:annotation office:name="__Annotation__4316_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:24:27.042982789</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Check Abc’Xyz</text:span></text:p>
      </office:annotation>checkword(scw, info, root)<office:annotation-end office:name="__Annotation__4316_1161223734"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (rv)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (pAMgr &amp;&amp; pAMgr-&gt;get_checksharps() &amp;&amp; scw.find(&quot;SS&quot;) != std::string::npos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>mkallsmall2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string u8buffer(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>rv = <office:annotation office:name="__Annotation__4317_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:24:50.489846743</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Spellsharps abcssabcss</text:span></text:p>
      </office:annotation>spellsharps<office:annotation-end office:name="__Annotation__4317_1161223734"/>(u8buffer, 0, 0, 0, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!rv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>mkinitcap2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>rv = <office:annotation office:name="__Annotation__4318_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:25:11.371221243</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Spellshaprs Abcssabcss</text:span></text:p>
      </office:annotation>spellsharps<office:annotation-end office:name="__Annotation__4318_1161223734"/>(scw, 0, 0, 0, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if ((abbv) &amp;&amp; !(rv)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>rv = <office:annotation office:name="__Annotation__4319_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:25:30.627337740</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Spellsharps abcssabcss.</text:span></text:p>
      </office:annotation>spellsharps<office:annotation-end office:name="__Annotation__4319_1161223734"/>(u8buffer, 0, 0, 0, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (!rv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>u8buffer = std::string(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>rv = <office:annotation office:name="__Annotation__4320_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:25:56.133600930</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P8"><text:span text:style-name="T5">Spellsharps Abcssabcss.</text:span></text:p>
      </office:annotation>spellsharps<office:annotation-end office:name="__Annotation__4320_1161223734"/>(u8buffer, 0, 0, 0, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (rv)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case INITCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// handle special capitalization of dotted I</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>bool Idot = (utf8 &amp;&amp; (unsigned char) scw[0] == 0xc4 &amp;&amp; (unsigned char) scw[1] == 0xb0);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>*info += SPELL_ORIGCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (captype == ALLCAP) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>mkallsmall2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>mkinitcap2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (Idot)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="13"/>scw.replace(0, 1, &quot;\xc4\xb0&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (captype == INITCAP)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>*info += SPELL_INITCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>rv = <office:annotation office:name="__Annotation__4322_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:26:36.691233230</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Check Abc</text:span></text:p>
      </office:annotation>checkword(scw, info, root)<office:annotation-end office:name="__Annotation__4322_1161223734"/>;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (captype == INITCAP)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>*info -= SPELL_INITCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// forbid bad capitalization</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// (for example, ijs -&gt; Ijs instead of IJs in Dutch)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// use explicit forms in dic: Ijs/F (F = FORBIDDENWORD flag)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (*info &amp; SPELL_FORBIDDEN) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>rv = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><office:annotation office:name="__Annotation__4326_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:28:20.466986765</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">ALLCAP input bit dictionary word is Initcap with keepcase flag which forbids different casing</text:span></text:p>
      </office:annotation><text:s text:c="6"/>if (rv &amp;&amp; is_keepcase(rv) &amp;&amp; (captype == ALLCAP))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>rv = NULL;<office:annotation-end office:name="__Annotation__4326_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (rv || (Idot &amp;&amp; langnum != LANG_az &amp;&amp; langnum != LANG_tr &amp;&amp; langnum != LANG_crh))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkallsmall2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string u8buffer(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkinitcap2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>rv = <office:annotation office:name="__Annotation__4323_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:27:25.452200648</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Check abc</text:span></text:p>
      </office:annotation>checkword<office:annotation-end office:name="__Annotation__4323_1161223734"/>(u8buffer, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (abbv &amp;&amp; !rv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>rv = <office:annotation office:name="__Annotation__4324_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:27:32.354172015</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Check abc.</text:span></text:p>
      </office:annotation>checkword<office:annotation-end office:name="__Annotation__4324_1161223734"/>(u8buffer, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!rv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>u8buffer = scw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (captype == INITCAP)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>*info += SPELL_INITCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>rv = <office:annotation office:name="__Annotation__4325_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:27:43.516056628</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Check Abc.</text:span></text:p>
      </office:annotation>checkword<office:annotation-end office:name="__Annotation__4325_1161223734"/>(u8buffer, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (captype == INITCAP)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>*info -= SPELL_INITCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (rv &amp;&amp; is_keepcase(rv) &amp;&amp; (captype == ALLCAP))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>rv = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (<office:annotation office:name="__Annotation__4327_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:29:33.796598289</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">ALLCAP input, but dict word is lowercase with keepcase flag forbidding different case.</text:span></text:p>
      </office:annotation>rv &amp;&amp; is_keepcase(rv) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>((captype == ALLCAP)<office:annotation-end office:name="__Annotation__4327_1161223734"/> ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="11"/>// if CHECKSHARPS: KEEPCASE words with \xDF <text:s/>are allowed</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="11"/>// in INITCAP form, too.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="11"/><office:annotation office:name="__Annotation__4328_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:30:22.348125702</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Initcap input, but dict word is lowercase with keepcase flag forbidding different case, except when the input word contains sharp s, ß.</text:span></text:p>
      </office:annotation>!(pAMgr-&gt;get_checksharps() &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="13"/>((utf8 &amp;&amp; u8buffer.find(&quot;\xC3\x9F&quot;) != std::string::npos) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>(!utf8 &amp;&amp; u8buffer.find(&apos;\xDF&apos;) != std::string::npos)))))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>rv = NULL;<office:annotation-end office:name="__Annotation__4328_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (rv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (pAMgr &amp;&amp; pAMgr-&gt;get_warn() &amp;&amp; rv-&gt;astr &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>TESTAFF(rv-&gt;astr, pAMgr-&gt;get_warn(), rv-&gt;alen)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>*info += SPELL_WARN;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (pAMgr-&gt;get_forbidwarn())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// recursive breaking at break points</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!<office:annotation office:name="__Annotation__4387_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:35:24.573658469</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">BREAK in aff. See manpage.</text:span></text:p>
      </office:annotation>wordbreak<office:annotation-end office:name="__Annotation__4387_1161223734"/>.empty() &amp;&amp; !(*info &amp; SPELL_FORBIDDEN)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>int nbr = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>wl = scw.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// calculate break points for recursion limit</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t j = 0; j &lt; wordbreak.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>size_t pos = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>while ((pos = scw.find(wordbreak[j], pos)) != std::string::npos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>++nbr;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>pos += wordbreak[j].size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (nbr &gt;= 10)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// check boundary patterns (^begin and end$)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t j = 0; j &lt; wordbreak.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>size_t plen = wordbreak[j].size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (plen == 1 || plen &gt; wl)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>continue;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (wordbreak[j][0] == &apos;^&apos; &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>scw.compare(0, plen - 1, wordbreak[j], 1, plen -1) == 0 &amp;&amp; <office:annotation office:name="__Annotation__4388_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:36:18.204348225</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">If BREAK pattern ^++</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T4">And word is ++abc++abc</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Spell abc++abc</text:span></text:p>
      </office:annotation>spell(scw.substr(plen - 1))<office:annotation-end office:name="__Annotation__4388_1161223734"/>)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (wordbreak[j][plen - 1] == &apos;$&apos; &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>scw.compare(wl - plen + 1, plen - 1, wordbreak[j], 0, plen - 1) == 0) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string suffix(scw.substr(wl - plen + 1));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>scw.resize(wl - plen + 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><office:annotation office:name="__Annotation__4391_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:38:13.160468647</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P8"><text:span text:style-name="T5">If BREAK pattern ++$</text:span></text:p>
       <text:p text:style-name="P8"><text:span text:style-name="T6">And word is abc++abc++</text:span></text:p>
       <text:p text:style-name="P8"><text:span text:style-name="T6">Spell abc++abc</text:span></text:p>
      </office:annotation><text:s text:c="8"/>if (spell(scw))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return true;<office:annotation-end office:name="__Annotation__4391_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>scw.append(suffix);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// other patterns</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/><office:annotation office:name="__Annotation__4392_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:39:24.222446370</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Assume break pattern is ++</text:span></text:p>
       <text:p text:style-name="P7"><text:span text:style-name="T4">And word is abc++xyz</text:span></text:p>
      </office:annotation><text:s text:c="3"/>for (size_t j = 0; j &lt; wordbreak.size(); ++j) {<office:annotation-end office:name="__Annotation__4392_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>size_t plen = wordbreak[j].size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>size_t found = scw.find(wordbreak[j]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((found &gt; 0) &amp;&amp; (found &lt; wl - plen)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!<office:annotation office:name="__Annotation__4393_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:40:08.371433842</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Spell xyz</text:span></text:p>
      </office:annotation>spell(scw.substr(found + plen)<office:annotation-end office:name="__Annotation__4393_1161223734"/>))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>continue;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string suffix(scw.substr(found));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>scw.resize(found);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>// examine 2 sides of the break point</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (<office:annotation office:name="__Annotation__4394_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:40:22.764683466</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Spell abc</text:span></text:p>
      </office:annotation>spell(scw)<office:annotation-end office:name="__Annotation__4394_1161223734"/>)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/><office:annotation office:name="__Annotation__4395_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:40:59.660505198</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Returns true if both spells are ok</text:span></text:p>
      </office:annotation>return true;<office:annotation-end office:name="__Annotation__4395_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>scw.append(suffix);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>// LANG_hu: spec. dash rule</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/><office:annotation office:name="__Annotation__4397_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:41:44.882738048</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P8"><text:span text:style-name="T5">Assume break pattern is -</text:span></text:p>
       <text:p text:style-name="P8"><text:span text:style-name="T6">And word is abc-xyz</text:span></text:p>
      </office:annotation>if (langnum == LANG_hu &amp;&amp; wordbreak[j] == &quot;-&quot;) {<office:annotation-end office:name="__Annotation__4397_1161223734"/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>suffix = scw.substr(found + 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>scw.resize(found + 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (<office:annotation office:name="__Annotation__4398_1161223734">
       <dc:creator>Dimitrij Mijoski</dc:creator>
       <dc:date>2018-01-18T23:42:21.906858686</dc:date>
       <loext:sender-initials>DM</loext:sender-initials>
       <text:p text:style-name="P7"><text:span text:style-name="T4">Spell abc-</text:span></text:p>
      </office:annotation>spell(scw)<office:annotation-end office:name="__Annotation__4398_1161223734"/>)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>return true; <text:s/>// check the first part with dash</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>scw.append(suffix);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>// end of LANG specific region</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">struct hentry* HunspellImpl::checkword(const std::string&amp; w, int* info, std::string* root) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>bool usebuffer = false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string w2;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* word;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int len;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* ignoredchars = pAMgr ? pAMgr-&gt;get_ignore() : NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (ignoredchars != NULL) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>w2.assign(w);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>const std::vector&lt;w_char&gt;&amp; ignoredchars_utf16 =</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>pAMgr-&gt;get_ignore_utf16();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>remove_ignored_chars_utf(w2, ignoredchars_utf16);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>remove_ignored_chars(w2, ignoredchars);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>word = w2.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>len = w2.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>usebuffer = true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>word = w.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>len = w.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!len)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// word reversing wrapper for complex prefixes</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (complexprefixes) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (!usebuffer) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>w2.assign(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>usebuffer = true;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (utf8)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>reverseword_utf(w2);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>reverseword(w2);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (usebuffer) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>word = w2.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// look word in hash table</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>struct hentry* he = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (size_t i = 0; (i &lt; m_HMgrs.size()) &amp;&amp; !he; ++i) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>he = m_HMgrs[i]-&gt;lookup(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// check forbidden and onlyincompound words</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if ((he) &amp;&amp; (he-&gt;astr) &amp;&amp; (pAMgr) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>TESTAFF(he-&gt;astr, pAMgr-&gt;get_forbiddenword(), he-&gt;alen)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (info)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>*info += SPELL_FORBIDDEN;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// LANG_hu section: set dash information for suggestions</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (langnum == LANG_hu) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (pAMgr-&gt;get_compoundflag() &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>TESTAFF(he-&gt;astr, pAMgr-&gt;get_compoundflag(), he-&gt;alen)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (info)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>*info += SPELL_COMPOUND;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// he = next not needaffix, onlyincompound homonym or onlyupcase word</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>while (he &amp;&amp; (he-&gt;astr) &amp;&amp; pAMgr &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="11"/>((pAMgr-&gt;get_needaffix() &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="13"/>TESTAFF(he-&gt;astr, pAMgr-&gt;get_needaffix(), he-&gt;alen)) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>(pAMgr-&gt;get_onlyincompound() &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="13"/>TESTAFF(he-&gt;astr, pAMgr-&gt;get_onlyincompound(), he-&gt;alen)) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>(info &amp;&amp; (*info &amp; SPELL_INITCAP) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="13"/>TESTAFF(he-&gt;astr, ONLYUPCASEFLAG, he-&gt;alen))))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>he = he-&gt;next_homonym;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// check with affixes</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!he &amp;&amp; pAMgr) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// try stripping off affixes */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>he = pAMgr-&gt;affix_check(word, len, 0);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// check compound restriction and onlyupcase</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (he &amp;&amp; he-&gt;astr &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>((pAMgr-&gt;get_onlyincompound() &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>TESTAFF(he-&gt;astr, pAMgr-&gt;get_onlyincompound(), he-&gt;alen)) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="9"/>(info &amp;&amp; (*info &amp; SPELL_INITCAP) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>TESTAFF(he-&gt;astr, ONLYUPCASEFLAG, he-&gt;alen)))) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>he = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (he) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((he-&gt;astr) &amp;&amp; (pAMgr) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>TESTAFF(he-&gt;astr, pAMgr-&gt;get_forbiddenword(), he-&gt;alen)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (info)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>*info += SPELL_FORBIDDEN;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (root) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>root-&gt;assign(he-&gt;word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (complexprefixes) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (utf8)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>reverseword_utf(*root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>reverseword(*root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// try check compound word</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else if (pAMgr-&gt;get_compound()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>struct hentry* rwords[100]; <text:s/>// buffer for COMPOUND pattern checking</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>he = pAMgr-&gt;compound_check(word, 0, 0, 100, 0, NULL, (hentry**)&amp;rwords, 0, 0, info);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// LANG_hu section: `moving rule&apos; with last dash</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((!he) &amp;&amp; (langnum == LANG_hu) &amp;&amp; (word[len - 1] == &apos;-&apos;)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string dup(word, len - 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>he = pAMgr-&gt;compound_check(dup, -5, 0, 100, 0, NULL, (hentry**)&amp;rwords, 1, 0, info);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// end of LANG specific region</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (he) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (root) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>root-&gt;assign(he-&gt;word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (complexprefixes) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (utf8)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>reverseword_utf(*root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>reverseword(*root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (info)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>*info += SPELL_COMPOUND;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return he;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; HunspellImpl::suggest(const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>int onlycmpdsug = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!pSMgr || m_HMgrs.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// process XML input of the simplified API (see manual)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (word.compare(0, sizeof(SPELL_XML) - 3, SPELL_XML, sizeof(SPELL_XML) - 3) == 0) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return spellml(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (word.size() &gt;= MAXWORDUTF8LEN)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (word.size() &gt;= MAXWORDLEN)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int captype = NOCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t abbv = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t wl = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string scw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;w_char&gt; sunicw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// input conversion</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>RepList* rl = (pAMgr) ? pAMgr-&gt;get_iconvtable() : NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>{</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string wspace;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>bool convstatus = rl ? rl-&gt;conv(word, wspace) : false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (convstatus)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>wl = cleanword2(scw, sunicw, wspace, &amp;captype, &amp;abbv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>wl = cleanword2(scw, sunicw, word, &amp;captype, &amp;abbv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (wl == 0)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int capwords = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// check capitalized form for FORCEUCASE</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (pAMgr &amp;&amp; captype == NOCAP &amp;&amp; pAMgr-&gt;get_forceucase()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>int info = SPELL_ORIGCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (checkword(scw, &amp;info, NULL)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string form(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkinitcap(form);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>slst.push_back(form);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>switch (captype) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case NOCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>pSMgr-&gt;suggest(slst, scw.c_str(), &amp;onlycmpdsug);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case INITCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>capwords = 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>pSMgr-&gt;suggest(slst, scw.c_str(), &amp;onlycmpdsug);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string wspace(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkallsmall2(wspace, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>pSMgr-&gt;suggest(slst, wspace.c_str(), &amp;onlycmpdsug);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>case HUHINITCAP:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>capwords = 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case HUHCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>pSMgr-&gt;suggest(slst, scw.c_str(), &amp;onlycmpdsug);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// something.The -&gt; something. The</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>size_t dot_pos = scw.find(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (dot_pos != std::string::npos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string postdot = scw.substr(dot_pos + 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>int captype_;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>std::vector&lt;w_char&gt; postdotu;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>u8_u16(postdotu, postdot);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>captype_ = get_captype_utf8(postdotu, langnum);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>captype_ = get_captype(postdot, csconv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (captype_ == INITCAP) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>std::string str(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>str.insert(dot_pos + 1, 1, &apos; &apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>insert_sug(slst, str);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string wspace;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (captype == HUHINITCAP) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>// TheOpenOffice.org -&gt; The OpenOffice.org</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>wspace = scw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>mkinitsmall2(wspace, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>pSMgr-&gt;suggest(slst, wspace.c_str(), &amp;onlycmpdsug);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>wspace = scw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkallsmall2(wspace, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (spell(wspace.c_str()))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>insert_sug(slst, wspace);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>size_t prevns = slst.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>pSMgr-&gt;suggest(slst, wspace.c_str(), &amp;onlycmpdsug);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (captype == HUHINITCAP) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>mkinitcap2(wspace, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (spell(wspace.c_str()))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>insert_sug(slst, wspace);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>pSMgr-&gt;suggest(slst, wspace.c_str(), &amp;onlycmpdsug);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// aNew -&gt; &quot;a New&quot; (instead of &quot;a new&quot;)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>for (size_t j = prevns; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>const char* space = strchr(slst[j].c_str(), &apos; &apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (space) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>size_t slen = strlen(space + 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>// different case after space (need capitalisation)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if ((slen &lt; wl) &amp;&amp; strcmp(scw.c_str() + wl - slen, space + 1)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>std::string first(slst[j].c_str(), space + 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>std::string second(space + 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>std::vector&lt;w_char&gt; w;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (utf8)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>u8_u16(w, second);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>mkinitcap2(second, w);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>// set as first suggestion</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>slst.erase(slst.begin() + j);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>slst.insert(slst.begin(), first + second);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>case ALLCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string wspace(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkallsmall2(wspace, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>pSMgr-&gt;suggest(slst, wspace.c_str(), &amp;onlycmpdsug);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (pAMgr &amp;&amp; pAMgr-&gt;get_keepcase() &amp;&amp; spell(wspace.c_str()))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>insert_sug(slst, wspace);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkinitcap2(wspace, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>pSMgr-&gt;suggest(slst, wspace.c_str(), &amp;onlycmpdsug);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>for (size_t j = 0; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>mkallcap(slst[j]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (pAMgr &amp;&amp; pAMgr-&gt;get_checksharps()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>mystrrep(slst[j], &quot;\xC3\x9F&quot;, &quot;SS&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>mystrrep(slst[j], &quot;\xDF&quot;, &quot;SS&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// LANG_hu section: replace &apos;-&apos; with &apos; &apos; in Hungarian</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (langnum == LANG_hu) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t j = 0; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>size_t pos = slst[j].find(&apos;-&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (pos != std::string::npos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>int info;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string w(slst[j].substr(0, pos));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>w.append(slst[j].substr(pos + 1));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>(void)spell(w, &amp;info, NULL);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if ((info &amp; SPELL_COMPOUND) &amp;&amp; (info &amp; SPELL_FORBIDDEN)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>slst[j][pos] = &apos; &apos;;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>} else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>slst[j][pos] = &apos;-&apos;;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// END OF LANG_hu section</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// try ngram approach since found nothing or only compound words</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (pAMgr &amp;&amp; (slst.empty() || onlycmpdsug) &amp;&amp; (pAMgr-&gt;get_maxngramsugs() != 0)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>switch (captype) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case NOCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>pSMgr-&gt;ngsuggest(slst, scw.c_str(), m_HMgrs);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case HUHINITCAP:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>capwords = 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case HUHCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string wspace(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>mkallsmall2(wspace, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>pSMgr-&gt;ngsuggest(slst, wspace.c_str(), m_HMgrs);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case INITCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>capwords = 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string wspace(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>mkallsmall2(wspace, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>pSMgr-&gt;ngsuggest(slst, wspace.c_str(), m_HMgrs);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case ALLCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string wspace(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="8"/>mkallsmall2(wspace, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>size_t oldns = slst.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>pSMgr-&gt;ngsuggest(slst, wspace.c_str(), m_HMgrs);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>for (size_t j = oldns; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>mkallcap(slst[j]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// try dash suggestion (Afo-American -&gt; Afro-American)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t dash_pos = scw.find(&apos;-&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (dash_pos != std::string::npos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>int nodashsug = 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t j = 0; j &lt; slst.size() &amp;&amp; nodashsug == 1; ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (slst[j].find(&apos;-&apos;) != std::string::npos)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>nodashsug = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>size_t prev_pos = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>bool last = false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>while (nodashsug &amp;&amp; !last) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (dash_pos == scw.size())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>last = 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string chunk = scw.substr(prev_pos, dash_pos - prev_pos);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (!spell(chunk.c_str())) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::vector&lt;std::string&gt; nlst = suggest(chunk.c_str());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>for (std::vector&lt;std::string&gt;::reverse_iterator j = nlst.rbegin(); j != nlst.rend(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>std::string wspace = scw.substr(0, prev_pos);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>wspace.append(*j);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (!last) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>wspace.append(&quot;-&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>wspace.append(scw.substr(dash_pos + 1));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>int info = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (pAMgr &amp;&amp; pAMgr-&gt;get_forbiddenword())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>checkword(wspace, &amp;info, NULL);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (!(info &amp; SPELL_FORBIDDEN))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>insert_sug(slst, wspace);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>nodashsug = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (!last) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>prev_pos = dash_pos + 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>dash_pos = scw.find(&apos;-&apos;, prev_pos);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (dash_pos == std::string::npos)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>dash_pos = scw.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// word reversing wrapper for complex prefixes</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (complexprefixes) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t j = 0; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (utf8)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>reverseword_utf(slst[j]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>reverseword(slst[j]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// capitalize</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>if (capwords)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t j = 0; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkinitcap(slst[j]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// expand suggestions with dot(s)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (abbv &amp;&amp; pAMgr &amp;&amp; pAMgr-&gt;get_sugswithdots()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t j = 0; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>slst[j].append(word.substr(word.size() - abbv));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// remove bad capitalized and forbidden forms</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (pAMgr &amp;&amp; (pAMgr-&gt;get_keepcase() || pAMgr-&gt;get_forbiddenword())) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>switch (captype) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case INITCAP:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>case ALLCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>size_t l = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>for (size_t j = 0; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (slst[j].find(&apos; &apos;) == std::string::npos &amp;&amp; !spell(slst[j])) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>std::string s;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>std::vector&lt;w_char&gt; w;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>u8_u16(w, slst[j]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>s = slst[j];</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>mkallsmall2(s, w);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>if (spell(s)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>slst[l] = s;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>++l;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>mkinitcap2(s, w);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>if (spell(s)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>slst[l] = s;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="16"/>++l;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="14"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>slst[l] = slst[j];</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>++l;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>slst.resize(l);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// remove duplications</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t l = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (size_t j = 0; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>slst[l] = slst[j];</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t k = 0; k &lt; l; ++k) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (slst[k] == slst[j]) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>--l;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>++l;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>slst.resize(l);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// output conversion</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>rl = (pAMgr) ? pAMgr-&gt;get_oconvtable() : NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (size_t j = 0; rl &amp;&amp; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>std::string wspace;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (rl-&gt;conv(slst[j], wspace)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>slst[j] = wspace;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const std::string&amp; HunspellImpl::get_dict_encoding() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return encoding;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; HunspellImpl::stem(const std::vector&lt;std::string&gt;&amp; desc) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string result2;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (desc.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (size_t i = 0; i &lt; desc.size(); ++i) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// add compound word parts (except the last one)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>const char* s = desc[i].c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>const char* part = strstr(s, MORPH_PART);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (part) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>const char* nextpart = strstr(part + 1, MORPH_PART);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>while (nextpart) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string field;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>copy_field(field, part, MORPH_PART);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>result.append(field);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>part = nextpart;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>nextpart = strstr(part + 1, MORPH_PART);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>s = part;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string tok(s);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>size_t alt = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>while ((alt = tok.find(&quot; | &quot;, alt)) != std::string::npos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>tok[alt + 1] = MSEP_ALT;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::vector&lt;std::string&gt; pl = line_tok(tok, MSEP_ALT);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t k = 0; k &lt; pl.size(); ++k) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// add derivational suffixes</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (pl[k].find(MORPH_DERI_SFX) != std::string::npos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>// remove inflectional suffixes</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>const size_t is = pl[k].find(MORPH_INFL_SFX);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (is != std::string::npos)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>pl[k].resize(is);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::vector&lt;std::string&gt; singlepl;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>singlepl.push_back(pl[k]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string sg = pSMgr-&gt;suggest_gen(singlepl, pl[k]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!sg.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>std::vector&lt;std::string&gt; gen = line_tok(sg, MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>for (size_t j = 0; j &lt; gen.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>result2.push_back(MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>result2.append(result);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>result2.append(gen[j]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>result2.push_back(MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="8"/>result2.append(result);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (pl[k].find(MORPH_SURF_PFX) != std::string::npos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>std::string field;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>copy_field(field, pl[k], MORPH_SURF_PFX);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>result2.append(field);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string field;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>copy_field(field, pl[k], MORPH_STEM);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>result2.append(field);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>slst = line_tok(result2, MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>uniqlist(slst);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; HunspellImpl::stem(const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return stem(analyze(word));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const std::string&amp; HunspellImpl::get_wordchars_cpp() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return pAMgr-&gt;get_wordchars();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const std::vector&lt;w_char&gt;&amp; HunspellImpl::get_wordchars_utf16() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return pAMgr-&gt;get_wordchars_utf16();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">void HunspellImpl::mkinitcap(std::string&amp; u8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::vector&lt;w_char&gt; u16;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>u8_u16(u16, u8);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>::mkinitcap_utf(u16, langnum);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>u16_u8(u8, u16);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>::mkinitcap(u8, csconv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::mkinitcap2(std::string&amp; u8, std::vector&lt;w_char&gt;&amp; u16) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>::mkinitcap_utf(u16, langnum);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>u16_u8(u8, u16);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>::mkinitcap(u8, csconv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return u8.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::mkinitsmall2(std::string&amp; u8, std::vector&lt;w_char&gt;&amp; u16) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>::mkinitsmall_utf(u16, langnum);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>u16_u8(u8, u16);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>::mkinitsmall(u8, csconv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return u8.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::add(const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!m_HMgrs.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return m_HMgrs[0]-&gt;add(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::add_with_affix(const std::string&amp; word, const std::string&amp; example) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!m_HMgrs.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return m_HMgrs[0]-&gt;add_with_affix(word, example);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::remove(const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!m_HMgrs.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return m_HMgrs[0]-&gt;remove(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const std::string&amp; HunspellImpl::get_version_cpp() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return pAMgr-&gt;get_version();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">struct cs_info* HunspellImpl::get_csconv() {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return csconv;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">void HunspellImpl::cat_result(std::string&amp; result, const std::string&amp; st) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!st.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (!result.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>result.append(&quot;\n&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>result.append(st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; HunspellImpl::analyze(const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!pSMgr || m_HMgrs.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (word.size() &gt;= MAXWORDUTF8LEN)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (word.size() &gt;= MAXWORDLEN)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int captype = NOCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t abbv = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t wl = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string scw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;w_char&gt; sunicw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// input conversion</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>RepList* rl = (pAMgr) ? pAMgr-&gt;get_iconvtable() : NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>{</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string wspace;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>bool convstatus = rl ? rl-&gt;conv(word, wspace) : false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (convstatus)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>wl = cleanword2(scw, sunicw, wspace, &amp;captype, &amp;abbv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>wl = cleanword2(scw, sunicw, word, &amp;captype, &amp;abbv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (wl == 0) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (abbv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>scw.clear();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>for (wl = 0; wl &lt; abbv; wl++)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>scw.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="6"/>abbv = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t n = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// test numbers</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// LANG_hu section: set dash information for suggestions</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (langnum == LANG_hu) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>size_t n2 = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>size_t n3 = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>while ((n &lt; wl) &amp;&amp; (((scw[n] &lt;= &apos;9&apos;) &amp;&amp; (scw[n] &gt;= &apos;0&apos;)) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="24"/>(((scw[n] == &apos;.&apos;) || (scw[n] == &apos;,&apos;)) &amp;&amp; (n &gt; 0)))) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>n++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((scw[n] == &apos;.&apos;) || (scw[n] == &apos;,&apos;)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (((n2 == 0) &amp;&amp; (n &gt; 3)) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>((n2 &gt; 0) &amp;&amp; ((scw[n - 1] == &apos;.&apos;) || (scw[n - 1] == &apos;,&apos;))))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>n2++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>n3 = n;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if ((n == wl) &amp;&amp; (n3 &gt; 0) &amp;&amp; (n - n3 &gt; 3))</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if ((n == wl) || ((n &gt; 0) &amp;&amp; ((scw[n] == &apos;%&apos;) || (scw[n] == &apos;\xB0&apos;)) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="22"/>checkword(scw.substr(n), NULL, NULL))) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>result.append(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>result.resize(n - 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (n == wl)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>cat_result(result, pSMgr-&gt;suggest_morph(scw.substr(n - 1)));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string chunk = scw.substr(n - 1, 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>cat_result(result, pSMgr-&gt;suggest_morph(chunk));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>result.push_back(&apos;+&apos;); <text:s/>// XXX SPEC. MORPHCODE</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>cat_result(result, pSMgr-&gt;suggest_morph(scw.substr(n)));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return line_tok(result, MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// END OF LANG_hu section</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>switch (captype) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case HUHCAP:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case HUHINITCAP:</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case NOCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>cat_result(result, pSMgr-&gt;suggest_morph(scw));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (abbv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string u8buffer(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>cat_result(result, pSMgr-&gt;suggest_morph(u8buffer));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case INITCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkallsmall2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string u8buffer(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkinitcap2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>cat_result(result, pSMgr-&gt;suggest_morph(u8buffer));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>cat_result(result, pSMgr-&gt;suggest_morph(scw));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (abbv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="8"/>cat_result(result, pSMgr-&gt;suggest_morph(u8buffer));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer = scw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>cat_result(result, pSMgr-&gt;suggest_morph(u8buffer));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>case ALLCAP: {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>cat_result(result, pSMgr-&gt;suggest_morph(scw));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (abbv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string u8buffer(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>cat_result(result, pSMgr-&gt;suggest_morph(u8buffer));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkallsmall2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string u8buffer(scw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkinitcap2(scw, sunicw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>cat_result(result, pSMgr-&gt;suggest_morph(u8buffer));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>cat_result(result, pSMgr-&gt;suggest_morph(scw));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (abbv) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>cat_result(result, pSMgr-&gt;suggest_morph(u8buffer));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer = scw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>u8buffer.push_back(&apos;.&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>cat_result(result, pSMgr-&gt;suggest_morph(u8buffer));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!result.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// word reversing wrapper for complex prefixes</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (complexprefixes) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (utf8)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>reverseword_utf(result);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>reverseword(result);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return line_tok(result, MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// compound word with dash (HU) I18n</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>// LANG_hu section: set dash information for suggestions</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>size_t dash_pos = langnum == LANG_hu ? scw.find(&apos;-&apos;) : std::string::npos;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (dash_pos != std::string::npos) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>int nresult = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string part1 = scw.substr(0, dash_pos);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string part2 = scw.substr(dash_pos+1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// examine 2 sides of the dash</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (part2.empty()) { <text:s/>// base word ending with dash</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (spell(part1)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string p = pSMgr-&gt;suggest_morph(part1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!p.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>slst = line_tok(p, MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>} else if (part2.size() == 1 &amp;&amp; part2[0] == &apos;e&apos;) { <text:s/>// XXX (HU) -e hat.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (spell(part1) &amp;&amp; (spell(&quot;-e&quot;))) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string st = pSMgr-&gt;suggest_morph(part1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!st.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>result.append(st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>result.push_back(&apos;+&apos;); <text:s/>// XXX spec. separator in MORPHCODE</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>st = pSMgr-&gt;suggest_morph(&quot;-e&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!st.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>result.append(st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return line_tok(result, MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// first word ending with dash: word- XXX ???</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>part1.push_back(&apos; &apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>nresult = spell(part1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>part1.erase(part1.size() - 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (nresult &amp;&amp; spell(part2) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>((part2.size() &gt; 1) || ((part2[0] &gt; &apos;0&apos;) &amp;&amp; (part2[0] &lt; &apos;9&apos;)))) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string st = pSMgr-&gt;suggest_morph(part1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!st.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>result.append(st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>result.push_back(&apos;+&apos;); <text:s/>// XXX spec. separator in MORPHCODE</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>st = pSMgr-&gt;suggest_morph(part2);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!st.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>result.append(st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return line_tok(result, MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// affixed number in correct word</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (nresult &amp;&amp; (dash_pos &gt; 0) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>(((scw[dash_pos - 1] &lt;= &apos;9&apos;) &amp;&amp; (scw[dash_pos - 1] &gt;= &apos;0&apos;)) ||</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="9"/>(scw[dash_pos - 1] == &apos;.&apos;))) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>n = 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (scw[dash_pos - n] == &apos;.&apos;)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>n++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// search first not a number character to left from dash</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>while ((dash_pos &gt;= n) &amp;&amp; ((scw[dash_pos - n] == &apos;0&apos;) || (n &lt; 3)) &amp;&amp;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="13"/>(n &lt; 6)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>n++;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (dash_pos &lt; n)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>n--;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// numbers: valami1000000-hoz</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// examine 100000-hoz, 10000-hoz 1000-hoz, 10-hoz,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>// 56-hoz, 6-hoz</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>for (; n &gt;= 1; n--) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (scw[dash_pos - n] &lt; &apos;0&apos; || scw[dash_pos - n] &gt; &apos;9&apos;) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>continue;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::string chunk = scw.substr(dash_pos - n);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (checkword(chunk, NULL, NULL)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>result.append(chunk);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>std::string st = pSMgr-&gt;suggest_morph(chunk);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>if (!st.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="12"/>result.append(st);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return line_tok(result, MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; HunspellImpl::generate(const std::string&amp; word, const std::vector&lt;std::string&gt;&amp; pl) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!pSMgr || pl.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; pl2 = analyze(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int captype = NOCAP;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int abbv = 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string cw;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>cleanword(cw, word, &amp;captype, &amp;abbv);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string result;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (size_t i = 0; i &lt; pl.size(); ++i) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>cat_result(result, pSMgr-&gt;suggest_gen(pl2, pl[i]));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!result.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// allcap</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (captype == ALLCAP)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mkallcap(result);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// line split</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>slst = line_tok(result, MSEP_REC);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// capitalize</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (captype == INITCAP || captype == HUHINITCAP) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>for (size_t j = 0; j &lt; slst.size(); ++j) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>mkinitcap(slst[j]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// temporary filtering of prefix related errors (eg.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// generate(&quot;undrinkable&quot;, &quot;eats&quot;) --&gt; &quot;undrinkables&quot; and &quot;*undrinks&quot;)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::vector&lt;std::string&gt;::iterator it = slst.begin();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>while (it != slst.end()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (!spell(*it)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>it = slst.erase(it);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>} else <text:s/>{</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>++it;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; HunspellImpl::generate(const std::string&amp; word, const std::string&amp; pattern) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; pl = analyze(pattern);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; slst = generate(word, pl);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>uniqlist(slst);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// minimal XML parser functions</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::string HunspellImpl::get_xml_par(const char* par) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string dest;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!par)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return dest;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>char end = *par;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (end == &apos;&gt;&apos;)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>end = &apos;&lt;&apos;;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>else if (end != &apos;\&apos;&apos; &amp;&amp; end != &apos;&quot;&apos;)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>return dest; <text:s/>// bad XML</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (par++; *par != &apos;\0&apos; &amp;&amp; *par != end; ++par) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>dest.push_back(*par);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>mystrrep(dest, &quot;&amp;lt;&quot;, &quot;&lt;&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>mystrrep(dest, &quot;&amp;amp;&quot;, &quot;&amp;&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return dest;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::get_langnum() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return langnum;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">bool HunspellImpl::input_conv(const std::string&amp; word, std::string&amp; dest) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>RepList* rl = pAMgr ? pAMgr-&gt;get_iconvtable() : NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (rl) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return rl-&gt;conv(word, dest);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>dest.assign(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return false;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// return the beginning of the element (attr == NULL) or the attribute</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const char* HunspellImpl::get_xml_pos(const char* s, const char* attr) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* end = strchr(s, &apos;&gt;&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (attr == NULL)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return end;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* p = s;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>while (1) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>p = strstr(p, attr);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (!p || p &gt;= end)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (*(p - 1) == &apos; &apos; || *(p - 1) == &apos;\n&apos;)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>p += strlen(attr);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return p + strlen(attr);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::check_xml_par(const char* q,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="28"/>const char* attr,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="28"/>const char* value) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string cw = get_xml_par(get_xml_pos(q, attr));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (cw == value)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; HunspellImpl::get_xml_list(const char* list, const char* tag) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!list)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* p = list;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (size_t n = 0; ((p = strstr(p, tag)) != NULL); ++p, ++n) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string cw = get_xml_par(p + strlen(tag) - 1);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (cw.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>break;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>slst.push_back(cw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; HunspellImpl::spellml(const std::string&amp; in_word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>std::vector&lt;std::string&gt; slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* word = in_word.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* q = strstr(word, &quot;&lt;query&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!q)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return slst; <text:s/>// bad XML input</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* q2 = strchr(q, &apos;&gt;&apos;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!q2)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return slst; <text:s/>// bad XML input</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>q2 = strstr(q2, &quot;&lt;word&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!q2)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return slst; <text:s/>// bad XML input</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (check_xml_par(q, &quot;type=&quot;, &quot;analyze&quot;)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string cw = get_xml_par(strchr(q2, &apos;&gt;&apos;));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (!cw.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>slst = analyze(cw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (slst.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>// convert the result to &lt;code&gt;&lt;a&gt;ana1&lt;/a&gt;&lt;a&gt;ana2&lt;/a&gt;&lt;/code&gt; format</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string r;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>r.append(&quot;&lt;code&gt;&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (size_t i = 0; i &lt; slst.size(); ++i) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>r.append(&quot;&lt;a&gt;&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string entry(slst[i]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mystrrep(entry, &quot;\t&quot;, &quot; &quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mystrrep(entry, &quot;&amp;&quot;, &quot;&amp;amp;&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>mystrrep(entry, &quot;&lt;&quot;, &quot;&amp;lt;&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>r.append(entry);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>r.append(&quot;&lt;/a&gt;&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>r.append(&quot;&lt;/code&gt;&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>slst.clear();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>slst.push_back(r);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else if (check_xml_par(q, &quot;type=&quot;, &quot;stem&quot;)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string cw = get_xml_par(strchr(q2, &apos;&gt;&apos;));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (!cw.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return stem(cw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else if (check_xml_par(q, &quot;type=&quot;, &quot;generate&quot;)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string cw = get_xml_par(strchr(q2, &apos;&gt;&apos;));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (cw.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>const char* q3 = strstr(q2 + 1, &quot;&lt;word&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (q3) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string cw2 = get_xml_par(strchr(q3, &apos;&gt;&apos;));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (!cw2.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return generate(cw, cw2);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if ((q2 = strstr(q2 + 1, &quot;&lt;code&quot;)) != NULL) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>std::vector&lt;std::string&gt; slst2 = get_xml_list(strchr(q2, &apos;&gt;&apos;), &quot;&lt;a&gt;&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>if (!slst2.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>slst = generate(cw, slst2);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>uniqlist(slst);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else if (check_xml_par(q, &quot;type=&quot;, &quot;add&quot;)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>std::string cw = get_xml_par(strchr(q2, &apos;&gt;&apos;));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (cw.empty())</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="4"/>const char* q3 = strstr(q2 + 1, &quot;&lt;word&quot;);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (q3) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>std::string cw2 = get_xml_par(strchr(q3, &apos;&gt;&apos;));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (!cw2.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>add_with_affix(cw, cw2);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>add(cw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>add(cw);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; HunspellImpl::suffix_suggest(const std::string&amp; root_word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>struct hentry* he = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int len;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string w2;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* word;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>const char* ignoredchars = pAMgr-&gt;get_ignore();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (ignoredchars != NULL) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>w2.assign(root_word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (utf8) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>const std::vector&lt;w_char&gt;&amp; ignoredchars_utf16 =</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="10"/>pAMgr-&gt;get_ignore_utf16();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>remove_ignored_chars_utf(w2, ignoredchars_utf16);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>remove_ignored_chars(w2, ignoredchars);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>word = w2.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>} else</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>word = root_word.c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>len = strlen(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (!len)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (size_t i = 0; (i &lt; m_HMgrs.size()) &amp;&amp; !he; ++i) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>he = m_HMgrs[i]-&gt;lookup(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (he) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>slst = pAMgr-&gt;get_suffix_words(he-&gt;astr, he-&gt;alen, root_word.c_str());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return slst;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">namespace {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>int munge_vector(char*** slst, const std::vector&lt;std::string&gt;&amp; items) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (items.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>*slst = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>*slst = (char**)malloc(sizeof(char*) * items.size());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>if (!*slst)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>for (size_t i = 0; i &lt; items.size(); ++i)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="8"/>(*slst)[i] = mystrdup(items[i].c_str());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return items.size();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::spell(const char* word, int* info, char** root) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string sroot;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>bool ret = spell(word, info, root ? &amp;sroot : NULL);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (root) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>if (sroot.empty()) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>*root = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>} else {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>*root = mystrdup(sroot.c_str());</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return ret;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::suggest(char*** slst, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; suggests = suggest(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return munge_vector(slst, suggests);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::suffix_suggest(char*** slst, const char* root_word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; stems = suffix_suggest(root_word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return munge_vector(slst, stems);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">void HunspellImpl::free_list(char*** slst, int n) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (slst &amp;&amp; *slst) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>for (int i = 0; i &lt; n; i++)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="6"/>free((*slst)[i]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>free(*slst);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>*slst = NULL;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">char* HunspellImpl::get_dic_encoding() {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return &amp;encoding[0];</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::analyze(char*** slst, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; stems = analyze(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return munge_vector(slst, stems);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::stem(char*** slst, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; stems = stem(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return munge_vector(slst, stems);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::stem(char*** slst, char** desc, int n) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; morph;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (int i = 0; i &lt; n; ++i)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>morph.push_back(desc[i]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; stems = stem(morph);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return munge_vector(slst, stems);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::generate(char*** slst, const char* word, const char* pattern) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; stems = generate(word, pattern);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return munge_vector(slst, stems);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::generate(char*** slst, const char* word, char** pl, int pln) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; morph;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>for (int i = 0; i &lt; pln; ++i)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>morph.push_back(pl[i]);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::vector&lt;std::string&gt; stems = generate(word, morph);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return munge_vector(slst, stems);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const char* HunspellImpl::get_wordchars() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return get_wordchars_cpp().c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const char* HunspellImpl::get_version() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return get_version_cpp().c_str();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int HunspellImpl::input_conv(const char* word, char* dest, size_t destsize) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>std::string d;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>bool ret = input_conv(word, d);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>if (ret &amp;&amp; d.size() &lt; destsize) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>strncpy(dest, d.c_str(), destsize);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="4"/>return 1;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return 0;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">Hunspell::Hunspell(const char* affpath, const char* dpath, const char* key)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>: m_Impl(new HunspellImpl(affpath, dpath, key)) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">Hunspell::~Hunspell() {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>delete m_Impl;</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">// load extra dictionaries</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::add_dic(const char* dpath, const char* key) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;add_dic(dpath, key);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">bool Hunspell::spell(const std::string&amp; word, int* info, std::string* root) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;spell(word, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; Hunspell::suggest(const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;suggest(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; Hunspell::suffix_suggest(const std::string&amp; root_word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;suffix_suggest(root_word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const std::string&amp; Hunspell::get_dict_encoding() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;get_dict_encoding();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; Hunspell::stem(const std::vector&lt;std::string&gt;&amp; desc) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;stem(desc);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; Hunspell::stem(const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;stem(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const std::string&amp; Hunspell::get_wordchars_cpp() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;get_wordchars_cpp();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const std::vector&lt;w_char&gt;&amp; Hunspell::get_wordchars_utf16() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/><text:s text:c="2"/>return m_Impl-&gt;get_wordchars_utf16();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::add(const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;add(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::add_with_affix(const std::string&amp; word, const std::string&amp; example) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;add_with_affix(word, example);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::remove(const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;remove(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const std::string&amp; Hunspell::get_version_cpp() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;get_version_cpp();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">struct cs_info* Hunspell::get_csconv() {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;get_csconv();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; Hunspell::analyze(const std::string&amp; word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;analyze(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; Hunspell::generate(const std::string&amp; word, const std::vector&lt;std::string&gt;&amp; pl) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;generate(word, pl);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">std::vector&lt;std::string&gt; Hunspell::generate(const std::string&amp; word, const std::string&amp; pattern) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;generate(word, pattern);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::get_langnum() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;get_langnum();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">bool Hunspell::input_conv(const std::string&amp; word, std::string&amp; dest) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;input_conv(word, dest);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::spell(const char* word, int* info, char** root) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;spell(word, info, root);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::suggest(char*** slst, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;suggest(slst, word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::suffix_suggest(char*** slst, const char* root_word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;suffix_suggest(slst, root_word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">void Hunspell::free_list(char*** slst, int n) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>m_Impl-&gt;free_list(slst, n);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">char* Hunspell::get_dic_encoding() {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;get_dic_encoding();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/></text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::analyze(char*** slst, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;analyze(slst, word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::stem(char*** slst, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;stem(slst, word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P5">int Hunspell::stem(char*** slst, char** desc, int n) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;stem(slst, desc, n);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::generate(char*** slst, const char* word, const char* pattern) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;generate(slst, word, pattern);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::generate(char*** slst, const char* word, char** pl, int pln) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;generate(slst, word, pl, pln);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const char* Hunspell::get_wordchars() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;get_wordchars();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">const char* Hunspell::get_version() const {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;get_version();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell::input_conv(const char* word, char* dest, size_t destsize) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return m_Impl-&gt;input_conv(word, dest, destsize);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">Hunhandle* Hunspell_create(const char* affpath, const char* dpath) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;Hunhandle*&gt;(new HunspellImpl(affpath, dpath));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">Hunhandle* Hunspell_create_key(const char* affpath,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="31"/>const char* dpath,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="31"/>const char* key) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;Hunhandle*&gt;(new HunspellImpl(affpath, dpath, key));</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">void Hunspell_destroy(Hunhandle* pHunspell) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>delete reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_add_dic(Hunhandle* pHunspell, const char* dpath) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;add_dic(dpath);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_spell(Hunhandle* pHunspell, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;spell(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">char* Hunspell_get_dic_encoding(Hunhandle* pHunspell) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;get_dic_encoding();</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_suggest(Hunhandle* pHunspell, char*** slst, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;suggest(slst, word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_analyze(Hunhandle* pHunspell, char*** slst, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;analyze(slst, word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:soft-page-break/>}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_stem(Hunhandle* pHunspell, char*** slst, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;stem(slst, word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_stem2(Hunhandle* pHunspell, char*** slst, char** desc, int n) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;stem(slst, desc, n);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_generate(Hunhandle* pHunspell,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="22"/>char*** slst,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="22"/>const char* word,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="22"/>const char* pattern)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">{</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;generate(slst, word, pattern);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_generate2(Hunhandle* pHunspell,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="23"/>char*** slst,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="23"/>const char* word,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="23"/>char** desc,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="23"/>int n)</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">{</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;generate(slst, word, desc, n);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">/* functions for run-time modification of the dictionary */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">/* add word to the run-time dictionary */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_add(Hunhandle* pHunspell, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;add(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">/* add word to the run-time dictionary with affix flags of</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* the example (a dictionary word): Hunspell will recognize</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>* affixed forms of the new word, too.</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s/>*/</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_add_with_affix(Hunhandle* pHunspell,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="28"/>const char* word,</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="28"/>const char* example) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;add_with_affix(word, example);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">/* remove word from the run-time dictionary */</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">int Hunspell_remove(Hunhandle* pHunspell, const char* word) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>return reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;remove(word);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"/>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">void Hunspell_free_list(Hunhandle* pHunspell, char*** list, int n) {</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4"><text:s text:c="2"/>reinterpret_cast&lt;HunspellImpl*&gt;(pHunspell)-&gt;free_list(list, n);</text:p>
    </text:list-item>
    <text:list-item>
     <text:p text:style-name="P4">}</text:p>
    </text:list-item>
   </text:list>
  </office:text>
 </office:body>
</office:document>